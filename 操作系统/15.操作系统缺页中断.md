### 深入理解【缺页中断】及FIFO、LRU、OPT这三种置换算法

缺页中断（英语：Page fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）指的是当软件试图访问已映射在[虚拟](https://baike.baidu.com/item/虚拟)[地址空间](https://baike.baidu.com/item/地址空间)中，但是目前并未被加载在[物理内存](https://baike.baidu.com/item/物理内存)中的一个[分页](https://baike.baidu.com/item/分页)时，由[中央处理器](https://baike.baidu.com/item/中央处理器)的内存管理单元所发出的[中断](https://baike.baidu.com/item/中断)。

通常情况下，用于处理此中断的程序是[操作系统](https://baike.baidu.com/item/操作系统)的一部分。如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的[虚拟内存](https://baike.baidu.com/item/虚拟内存)文件中调入内存。而如果访问是不被允许的，那么操作系统通常会结束相关的[进程](https://baike.baidu.com/item/进程)。

虽然其名为“页缺失”错误，但实际上这并不一定是一种错误。而且这一机制对于利用[虚拟内存](https://baike.baidu.com/item/虚拟内存)来增加程序可用内存空间的操作系统（比如[Microsoft Windows](https://baike.baidu.com/item/Microsoft Windows)和各种[类Unix系统](https://baike.baidu.com/item/类Unix系统)）中都是常见且有必要的。

微软在较新版Windows的[资源监视器](https://baike.baidu.com/item/资源监视器)中使用“硬错误”（[Windows Vista](https://baike.baidu.com/item/Windows Vista)及以上）、“硬中断”（[Windows 8](https://baike.baidu.com/item/Windows 8)及以上）这一术语来指代“页缺失”。

 

#### 分类

##### 软性

软性页缺失指页缺失发生时，相关的页已经被加载进内存，但是没有向MMU注册的情况。操作系统只需要在MMU中注册相关页对应的物理地址即可。

发生这种情况的可能性之一，是一块物理内存被两个或多个程序[共享](https://baike.baidu.com/item/共享)，操作系统已经为其中的一个装载并注册了相应的页，但是没有为另一个程序注册。

可能性之二，是该页已被从CPU的[工作集](https://baike.baidu.com/item/工作集)中移除，但是尚未被交换到[磁盘](https://baike.baidu.com/item/磁盘)上。比如[OpenVMS](https://baike.baidu.com/item/OpenVMS)这样的使用次级页缓存的系统，就有可能会在工作集过大的情况下，将某页从工作集中去除，但是不写入硬盘也不擦除（比如说这一页被读出硬盘后没被修改过），只是放入空闲页表。除非有其他程序需要，导致这一页被分配出去了，不然这一页的内容不会被修改。当原程序再次需要该页内的数据时，如果这一页确实没有被分配出去，那么系统只需要重新为该页在MMU内注册映射即可。

 

##### 硬性

与软性页缺失相反，硬性页缺失是指相关的页在页缺失发生时未被加载进内存的情况。这时操作系统需要：

1. 寻找到一个空闲的页。或者把另外一个使用中的页写到磁盘上（如果其在最后一次写入后发生了变化的话），并注销在MMU内的记录
2. 将数据读入被选定的页
3. 向MMU注册该页

硬性页缺失导致的性能损失是很大的。以一块7200[rpm](https://baike.baidu.com/item/rpm)的主流[机械硬盘](https://baike.baidu.com/item/机械硬盘)为例，其平均寻道时间为8.5毫秒，读入内存需要0.05毫秒。相对的，[DDR3内存](https://baike.baidu.com/item/DDR3内存)的访问延迟通常在数十到100纳秒之间，性能差距可能会达到8万到22万倍。

另外，有些操作系统会将程序的一部分延迟到需要使用的时候再加载入内存执行，以此来提升性能。这一特性也是通过捕获硬性页缺失达到的。

当硬性页缺失过于频繁的发生时，称发生系统颠簸。

 

##### 无效

当程序访问的虚拟地址是不存在于虚拟地址空间内的时候，则发生无效页缺失。一般来说这是个软件问题，但是也不排除硬件可能，比如因为内存故障而损坏了一个正确的[指针](https://baike.baidu.com/item/指针)。

具体动作与所使用的操作系统有关，比如Windows会使用[异常](https://baike.baidu.com/item/异常)机制向程序报告，而[类Unix系统](https://baike.baidu.com/item/类Unix系统)则会使用[信号](https://baike.baidu.com/item/信号)机制。如果程序未处理相关问题，那么操作系统会执行默认处理方式，通常是转储内存、终止相关的程序，然后向用户报告。

 

#### 中断

是指计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回现行程序的间断处，继续执行原程序。

 

##### 缺页中断的次数

中断次数=进程的物理块数×页面置换次数。

 

##### 缺页中断的顺序

缺页中断发生时的事件顺序如下：

1) 硬件陷入内核，在内核[堆栈](https://baike.baidu.com/item/堆栈)中保存[程序计数器](https://baike.baidu.com/item/程序计数器)。大多数机器将当前指令的各种状态信息保存在特殊的CPU[寄存器](https://baike.baidu.com/item/寄存器)中。
2) 启动一个汇编代码例程保存[通用寄存器](https://baike.baidu.com/item/通用寄存器)和其他易失的信息，以免被操作系统破坏。这个例程将操作系统作为一个函数来调用。
3) 操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么。
4) 一旦知道了发生缺页中断的[虚拟地址](https://baike.baidu.com/item/虚拟地址)，操作系统检查这个地址是否有效，并检查存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲[页框](https://baike.baidu.com/item/页框)。如果没有空闲页框，执行[页面置换算法](https://baike.baidu.com/item/页面置换算法)寻找一个页面来淘汰。
5) 如果选择的页框“脏”了，安排该页写回磁盘，并发生一次[上下文切换](https://baike.baidu.com/item/上下文切换)，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用。
6) 一旦页框“干净”后（无论是立刻还是在写回磁盘后），操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面被装入后，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行。
7) 当磁盘中断发生时，表明该页已经被装入，[页表](https://baike.baidu.com/item/页表)已经更新可以反映它的位置，[页框](https://baike.baidu.com/item/页框)也被标记为正常状态。
8) 恢复发生缺页[中断指令](https://baike.baidu.com/item/中断指令)以前的状态，[程序计数器](https://baike.baidu.com/item/程序计数器)重新指向这条指令。
9) 调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程。
10) 该例程恢复寄存器和其他状态信息

 



# 1. 缺页中断

　　在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。 
　　缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤： 
　　1. 保护CPU现场 
　　2. 分析中断原因 
　　3. 转入缺页中断处理程序进行处理 
　　4. 恢复CPU现场，继续执行 
　　但是缺页中断时由于所要访问的页面不存在与内存时，有硬件所产生的一种特殊的中断，因此，与一般的中断存在区别： 
　　 1. 在指令执行期间产生和处理缺页中断信号 
　　 2. 一条指令在执行期间，可能产生多次缺页中断 
　　 3. 缺页中断返回时，执行产生中断的那一条指令，而一般的中断返回时，执行下一条指令





# 2. 页面置换算法

　　进程运行过程中，如果发生缺页中断，而此时内存中有没有空闲的物理块是，为了能够把所缺的页面装入内存，系统必须从内存中选择一页调出到磁盘的对换区。但此时应该把那个页面换出，则需要根据一定的页面置换算法（Page Replacement Algorithm)来确定。

## 2.1 最佳置换（Optimal， OPT)

### 2.1.1 基本思想

　　置换以后不再被访问，或者在将来最迟才回被访问的页面，缺页中断率最低。但是该算法需要依据以后各业的使用情况，而当一个进程还未运行完成是，很难估计哪一个页面是以后不再使用或在最长时间以后才会用到的页面。所以该算法是不能实现的。但该算法仍然有意义，作为很亮其他算法优劣的一个标准。



### 2.1.2 算例

　　采用固定分配局部置换的策略，嘉定系统为某进程在内存中分配了3个物理块，页面访问顺序为2、3、2、1、5、2、4、5、3、2、5、2。假定系统未采用预调页策略，即未事先调入任何页面。进程运行时，一次将2、3、1三个页面调入内存，发生3次缺页中断。当第一次访问页面5时，产生第4次缺页中断，根据OPT算法，淘汰页面1，因为它在以后不会在使用了；第5次缺页中断时，淘汰页面2，因为它在5、3、2三个页面中，是在将来最迟才会被页面访问的页面。以此类推： 
　　注意：第4次中断时将最后不会访问的1剔除，将最后才访问的3放入最下面的内存块中，以后的调度过程中，最后不会访问或最后才被访问的页面总是放在最下面的内存块中。内存块从上到下依次存放最先访问的页面。 
　　中断次数为6，缺页中断率为6/12*100% = 50%。

|  P:  |  2   |  3   |  2   |  1   |  5   |  2   |  4   |  5   |  3   |  2   |  5   |  2   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| M=3  |  2   |  2   |  2   |  2   |  2   |  5   |  5   |  3   |  5   |  5   |  2   |  2   |
|      |      |  3   |  3   |  3   |  5   |  3   |  3   |  5   |  4   |  2   |  5   |  5   |
|      |      |      |      |  1   |  3   |  2   |  4   |  4   |  3   |  4   |  4   |  4   |
| F=5  |  Y   |  Y   |      |  Y   |  Y   |      |  Y   |      |      |  Y   |      |      |



## 2.2 先进先出置换算法（First In First Out, FIFO)

### 2.2.1 基本思想

　　置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。但是该算法会淘汰经常访问的页面，不适应进程实际运行的规律，目前已经很少使用。



### 2.2.2 算例

　　仍然以OPT算例为例子。 
　　中断次数为6，缺页中断率为9/12*100% = 75%。

|  P:  |  2   |  3   |  2   |  1   |  5   |  2   |  4   |  5   |  3   |  2   |  5   |  2   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| M=3  |  2   |  3   |  3   |  1   |  5   |  2   |  4   |  4   |  3   |  3   |  5   |  2   |
|      |      |  2   |  2   |  3   |  1   |  5   |  2   |  2   |  4   |  4   |  3   |  5   |
|      |      |      |      |  2   |  3   |  1   |  5   |  5   |  2   |  2   |  4   |  3   |
| F=9  |  Y   |  Y   |      |  Y   |  Y   |  Y   |  Y   |      |  Y   |      |      |  Y   |



### 2.2.3 Belady异常

　　一般来说，分配给进程的物理块越多，运行时的缺页次数应该越少，使用FIFO时，可能存在相反情况，分配4个物理块的缺页竟然比3个物理块的缺页次数还多！ 
　　例如：进程访问顺序为0、2、1、3、0、2、4、0、2、1、3、4。 
　　M=3时，缺页中断9次。缺页中断率9/12*100% = 75%。

|  P:  |  0   |  2   |  1   |  3   |  0   |  2   |  4   |  0   |  2   |  1   |  3   |  4   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| M=3  |  0   |  2   |  1   |  3   |  0   |  2   |  4   |  4   |  4   |  1   |  3   |  3   |
|      |      |  0   |  2   |  1   |  3   |  0   |  2   |  2   |  2   |  4   |  1   |  1   |
|      |      |      |  0   |  2   |  1   |  3   |  0   |  0   |  0   |  2   |  4   |  4   |
| F=9  |  Y   |  Y   |  Y   |  Y   |  Y   |  Y   |  Y   |      |      |  Y   |  Y   |      |

　　Ｍ=4时，缺页中断10次。缺页中断率10/12*100% = 83.3%。

|  P:  |  0   |  2   |  1   |  3   |  0   |  2   |  4   |  0   |  2   |  1   |  3   |  4   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| M=4  |  0   |  2   |  1   |  3   |  3   |  3   |  4   |  0   |  2   |  1   |  3   |  4   |
|      |      |  0   |  2   |  1   |  1   |  1   |  3   |  4   |  0   |  2   |  1   |  3   |
|      |      |      |  0   |  2   |  2   |  2   |  1   |  3   |  4   |  0   |  2   |  1   |
|      |      |      |      |  0   |  0   |  0   |  2   |  1   |  3   |  4   |  0   |  2   |
| F=10 |  Y   |  Y   |  Y   |  Y   |      |      |  Y   |  Y   |  Y   |  Y   |  Y   |  Y   |





## 2.3 最近最久未使用置换算法（Least Recently Used， LRU）

### 2.3.1 基本思想

　　置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。 
　　LRU算法普偏地适用于各种类型的程序，但是系统要时时刻刻对各页的访问历史情况加以记录和更新，开销太大，因此LRU算法必须要有硬件的支持。



### 2.3.2 算例

　　仍然以OPT算例为例子。 
　　中断次数为6，缺页中断率为7/12*100% = 58.3%。

|  P:  |  2   |  3   |  2   |  1   |  5   |  2   |  4   |  5   |  3   |  2   |  5   |  2   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| M=3  |  2   |  3   |  2   |  1   |  5   |  2   |  4   |  5   |  3   |  2   |  5   |  2   |
|      |      |  2   |  3   |  2   |  1   |  5   |  2   |  4   |  5   |  3   |  2   |  5   |
|      |      |      |      |  3   |  2   |  1   |  5   |  2   |  4   |  5   |  3   |  3   |
| F=7  |  Y   |  Y   |      |  Y   |  Y   |      |  Y   |      |  Y   |  Y   |      |      |

　　堆栈实现LRU： 
　　系统使用特殊的堆栈来存放内存中每一个页面的页号。每当访问一页时就调整一次，即把被访问页面的页号从栈中移出再压入栈顶。因此，栈顶始终是最新被访问页面的页号，栈底始终是最近最久未被访问的页号。当发生缺页中断时，总是淘汰栈底页号所对应的页面。 
　　