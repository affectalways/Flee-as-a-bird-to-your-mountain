# 03.协程管理

**目录**

- [协程是什么](#协程是什么)
- [协程的历史](#协程的历史)
- [为什么需要协程](#为什么需要协程)
- [进阶](#进阶)
- [参考链接](#参考链接)





#### 协程是什么

​		协程，英文名Coroutine。

​		是一种**用户态**的轻量级线程，**协程的调度完全由用户控制**。

​		协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方。在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

（1）协程执行的效率非常高。

（2）协程不需要多线程的锁机制





#### 为什么需要协程

​		首先解释：协程是非抢占式多任务，线程是抢占式多任务。

​		协程需要编写代码者主动让出控制权，而线程可以无需规划让出控制权的时间点。

​		协程哪怕没有操作系统干预也可以实现，毕竟任何编程语言自身就能够实现这个结构。早期的多任务大多来自于此。所以协程肯定是早于线程出现的。

​		最初，抢占式多任务的发明是一个feature，不需要考虑程序在何处被插入，就可以自动的实现多任务。很多人觉得这很方便。

​		然而后来，线程的弊端慢慢显现，一方面是程序不知道在什么时间点会被抢走焦点因此无法更有效的规划数据访问，二方面是线程需要有额外开销，有大量并行任务时不适合使用线程，例如C10K问题需要在短时间内响应一万个请求，而当时的系统尚不能有效处理一万个线程。

​		于是，协程重新回到了程序员的视线。因为一方面，协程代码中所有让出控制权的结点都是已知的，不会存在多线程同步方面的相关问题。二方面，协程的开销非常小，成千上万个协程并发也完全没问题。

> ​		从实用角度来讲，又把协程拿出来用，主要是解决高并发问题，线程是系统管理、调度的，也就是线程无论执行到哪，都得被系统打断、恢复，所以线程额外占用了很多资源，比如线程各自的栈空间，并且系统内核管理线程还需要用户态、内核态的上下文切换，所以开销比较大。而协程是用户态，不涉及内核态，就像来回切换一些函数，基本没什么开销。





#### 协程的历史

有的同学可能认为协程是一种比较新的技术，然而其实协程这种概念早在1958年就已经提出来了，**要知道这时线程的概念都还没有提出来**。

到了1972年，终于有编程语言实现了这个概念，这两门编程语言就是Simula 67 以及Scheme。

但协程这个概念始终没有流行起来，甚至在1993年还有人考古一样专门写论文挖出协程这种古老的技术。

因为这一时期还没有线程，如果你想在操作系统写出并发程序那么你将不得不使用类似协程这样的技术，后来线程开始出现，操作系统终于开始原生支持程序的并发执行，就这样，协程逐渐淡出了程序员的视线。

直到近些年，随着互联网的发展，尤其是移动互联网时代的到来，**服务端对高并发的要求越来越高，协程再一次重回技术主流**，各大编程语言都已经支持或计划开始支持协程。





#### 进阶

**普通的函数**

我们先来看一个普通的函数，这个函数非常简单：

```python
def func():   
	print("a")   
	print("b")   
	print("c")
```

执行函数func，打印结果：

```
abc
```

注意这段代码是用python写的，**但本篇关于协程的讨论适用于任何一门语言**，**因为协程并不是一种语言的特性**。而我们只不过恰好使用了python来用作示例，因其足够简单。



**从普通函数到协程**

接下来，我们就要从普通函数过渡到协程了。

和普通函数只有一个返回点不同，协程可以有**多个返回点**。

这是什么意思呢？

```python
def func() {
  print("a")
  暂停并返回
  print("b")
  暂停并返回
  print("c")
}
```

普通函数下，只有当执行完print("c")这句话后函数才会返回，但是在协程下当执行完print("a")后func就会因“暂停并返回”这段代码返回到调用函数。

协程之所以神奇就神奇在当我们从协程返回后**还能继续调用该协程**，并且是**从该协程的上一个返回点后继续执行**。

`"暂停并返回"`在python中一般叫做**yield**

需要注意的是，当普通函数返回后，进程的地址空间中不会再保存该函数运行时的任何信息，而协程返回后，函数的运行时信息是需要保存下来的，那么函数的运行时状态到底在内存中是什么样子呢？可以看之后的。

接下来，就用实际的代码看一看协程。



**Show Me The Code**

使用一个真实的例子来讲解，语言采用python

在python语言中，`"暂停并返回"`使用关键词yield，这样func函数就变成了

```
def func() {
  print("a")
  yield
  print("b")
  yield
  print("c")
}
```

注意，这时func就不再是简简单单的函数了，而是升级成为了协程，那么该怎么使用，很简单：

```
def A():
  co = func() # 得到该协程
  next(co)    # 调用协程
  print("in function A") # do something
  next(co)    # 再次调用该协程
```

我们看到虽然func函数没有return语句，也就是说虽然没有返回任何值，但是我们依然可以写co = func()这样的代码，意思是说co就是我们拿到的协程了。

接下来我们调用该协程，使用next(co)，运行函数A看看执行到第3行的结果是什么：

```
a
```

显然，和我们的预期一样，协程func在print("a")后因执行yield而暂停并返回函数A。

接下来是第4行，这个毫无疑问，A函数在做一些自己的事情，因此会打印：

```
a
in function A
```

接下来是重点的一行，当执行第5行再次调用协程时该打印什么呢？

如果func是普通函数，那么会执行func的第一行代码，也就是打印a。

但func不是普通函数，而是协程，我们之前说过，协程会在上一个返回点继续运行，因此这里应该执行的是func函数第一个yield之后的代码，也就是print("b")。

```
a
in function A
b
```

看到了吧，协程是一个很神奇的函数，它会自己记住之前的执行状态，当再次调用时会从上一次的返回点继续执行。



**图形化解释**

为了让你更加彻底的理解协程，我们使用图形化的方式再看一遍，首先是**普通的函数调用**：

![](https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya2TqUIL71iaFGrfLyXvYFvxSSXKIzHDB4fJn8dGkVciaWkrATA1wUFoN3fLMnbvenZaXmCwHZ6uOtVw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在该图中，方框内表示该函数的指令序列，如果该函数不调用任何其它函数，那么应该从上到下依次执行，但函数中可以调用其它函数，因此其执行并不是简单的从上到下，箭头线表示执行流的方向。

从图中我们可以看到，我们首先来到funcA函数，执行一段时间后发现调用了另一个函数funcB，这时控制转移到该函数，执行完成后回到main函数的调用点继续执行。

这是普通的函数调用。



接下来是**协程**

![](https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya2TqUIL71iaFGrfLyXvYFvxSu8ALIR50ZUYLicbRUOxp33Q5QEmhopEqLiclFMtZ9Q4yxvsHcGkBm1dg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在这里，我们依然首先在funcA函数中执行，运行一段时间后调用协程，协程开始执行，直到第一个挂起点，此后就像普通函数一样返回funcA函数，funcA函数执行一些代码后再次调用该协程，注意，协程这时就和普通函数不一样了，协程并不是从第一条指令开始执行而是**从上一次的挂起点开始执行**，执行一段时间后遇到第二个挂起点，这时协程再次像普通函数一样返回funcA函数，funcA函数执行一段时间后整个程序结束。

![](https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya2TqUIL71iaFGrfLyXvYFvxSnhFSFuGasOZrFsEZibH7GafdVeK8ebHe8h0oADWezzQIH6WNiaAicy56Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



**函数只是协程的一种特例**

怎么样，神奇不神奇，**和普通函数不同的是，协程能知道自己上一次执行到了哪里**。

现在你应该明白了吧，协程会在函数被暂停运行时保存函数的运行状态，并可以从保存的状态中恢复并继续运行。

很熟悉的味道有没有，这不就是操作系统对线程的调度嘛，线程也可以被暂停，操作系统保存线程运行状态然后去调度其它线程，此后该线程再次被分配CPU时还可以继续运行，就像没有被暂停过一样。

只不过线程的调度是操作系统实现的，这些对程序员都不可见，而协程是在用户态实现的，对程序员可见。

这就是为什么有的人说可以把协程理解为用户态线程的原因。

也就是说现在程序员可以扮演操作系统的角色了，你可以自己控制协程在什么时候运行，什么时候暂停，也就是说协程的调度权在你自己手上。





#### 协程是如何实现的

协程之所以可以被暂停也可以继续，那么一定要记录下被暂停时的状态，也就是上下文，当继续运行的时候要恢复其上下文(状态)，那么接下来很自然的一个问题就是，函数运行时的状态是什么？

这个关键的问题的答案就在《[**函数运行起来后在内存中是什么样子的**](http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&mid=2247484963&idx=1&sn=542d3bec57c6a9dfc17c83005fd2c030&chksm=fcb9817dcbce086b10cb44cad7c9777b0088fb8d9d6baf71ae36a9b03e1f8ef5bec62b79d6f7&scene=21#wechat_redirect)》这篇文章中，函数运行时所有的状态信息都位于函数运行时栈中。

函数运行时栈就是我们需要保存的状态，也就是所谓的上下文，如图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya2TqUIL71iaFGrfLyXvYFvxSGFveVaakh1CaurTHfTUnzaoWTyZuWiaoibuuCKr9UV2Z0jSKiacWKjamg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

从图中我们可以看出，该进程中只有一个线程，栈区中有四个栈帧，main函数调用A函数，A函数调用B函数，B函数调用C函数，当C函数在运行时整个进程的状态就如图所示。

现在我们已经知道了函数的运行时状态就保存在栈区的栈帧中，接下来重点来了哦。

既然函数的运行时状态保存在栈区的栈帧中，那么如果我们想暂停协程的运行就必须保存整个栈帧的数据，那么我们该将整个栈帧中的数据保存在哪里呢？

**堆区**，heap，我们可以将栈帧保存在堆区中，在堆区中开辟空间就是我们常用的C语言中的malloc或者C++中的new。

我们需要做的就是在堆区中申请一段空间，让后把协程的整个栈区保存下，当需要恢复协程的运行时再从堆区中copy出来恢复函数运行时状态。

再仔细想一想，为什么我们要这么麻烦的来回copy数据呢？

实际上，我们需要做的是直接把协程的运行需要的栈帧空间直接开辟在堆区中，这样都不用来回copy数据了，如图所示。

![图片](https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya2TqUIL71iaFGrfLyXvYFvxS16gcmON6BYgBicoyRUsPoxX47S53LZq3sRUxbmmJZRicRP4KImHSgFaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

从图中我们可以看到，该程序中开启了两个协程，这两个协程的栈区都是在堆上分配的，这样我们就可以随时中断或者恢复协程的执行了。

有的同学可能会问，那么进程地址空间最上层的栈区现在的作用是什么呢？

这一区域依然是用来保存函数栈帧的，只不过这些函数并不是运行在协程而是普通线程中的。

现在你应该看到了吧，在上图中实际上有3个执行流：

1. 一个普通线程
2. 两个协程

虽然有3个执行流但我们创建了几个线程呢？

> **一个线程**。

现在你应该明白为什么要使用协程了吧，使用协程理论上我们可以**开启无数并发执行流，只要堆区空间足够**，同时还没有创建线程的开销，所有协程的调度、切换都发生在用户态，这就是为什么协程也被称作用户态线程的原因所在。

因此即使你创建了N多协程，但在操作系统看来依然只有一个线程，也就是说协程对操作系统来说是不可见的。

这也许是为什么协程这个概念比线程提出的要早的原因，可能是写普通应用的程序员比写操作系统的程序员最先遇到需要多个并行流的需求，那时可能都还没有操作系统的概念，或者操作系统没有并行这种需求，所以非操作系统程序员只能自己动手实现执行流，也就是协程。





#### 参考链接

- https://www.zhihu.com/question/504791946
- https://github.com/xfenglu/everycodershouldknow