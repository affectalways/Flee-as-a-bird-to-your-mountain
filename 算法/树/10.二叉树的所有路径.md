# 10.二叉树的所有路径

**目录**

- [领扣题](#领扣题)



##### **领扣题**

##### [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

难度简单790

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

**示例 2：**

```
输入：root = [1]
输出：["1"]
```

 

**提示：**

- 树中节点的数目在范围 `[1, 100]` 内
- `-100 <= Node.val <= 100`

通过次数232,220

提交次数331,485

请问您在哪类招聘中遇到此题？





## 解题思路

> 深度优先搜索

最直观的方法是使用深度优先搜索。在深度优先搜索遍历二叉树时，我们需要考虑当前的节点以及它的孩子节点。

- 如果当前节点不是叶子节点，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。

- 如果当前节点是叶子节点，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可。

```python
class Solution:
    def binaryTreePaths(self, root):
        res = []
        path = []
        nodes = [(root, 0)]
        while nodes:
            # 注意！！！不是pop(0)，而是pop最末尾的，实现后序遍历
            cur, depth = nodes.pop()
            while len(path) > depth:
                path.pop()

            path.append(str(cur.val))

            if not (cur.left or cur.right):
                res.append("->".join(path[:]))
                continue

            if cur.left:
                nodes.append((cur.left, depth + 1))

            if cur.right:
                nodes.append((cur.right, depth + 1))

        return res

```

