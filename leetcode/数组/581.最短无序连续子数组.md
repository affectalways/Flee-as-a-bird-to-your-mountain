# [581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)

难度中等904

给你一个整数数组 `nums` ，你需要找出一个 **连续子数组** ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

请你找出符合题意的 **最短** 子数组，并输出它的长度。

 

**示例 1：**

```
输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
```

**示例 2：**

```
输入：nums = [1,2,3,4]
输出：0
```

**示例 3：**

```
输入：nums = [1]
输出：0
```

 

**提示：**

- `1 <= nums.length <= 104`
- `-105 <= nums[i] <= 105`

 

**进阶：**你可以设计一个时间复杂度为 `O(n)` 的解决方案吗？





## 思路

我们可以假设把这个数组分成三段，**左段**和右段是标准的**升序数组**，中段数组虽是**无序**的，但满足最小值大于左段的最大值，最大值小于右段的最小值。

![](https://pic.leetcode-cn.com/1600691648-ZCYlql-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200921203355.png)

那么我们目标就很明确了，找中段的左右边界，我们分别定义为**begin** 和 **end**;
分两头开始遍历:

- 从左到右维护一个最大值**max**,在进入右段之前，那么遍历到的**nums[i]**都是小于**max**的，我们要求的**end**就是遍历中最后一个小于max元素的位置；
- 同理，从右到左维护一个最小值**min**，在进入左段之前，那么遍历到的nums[i]也都是大于**min**的，要求的**begin**也就是最后一个大于**min**元素的位置。



```python
class Solution:
    def findUnsortedSubarray(self, nums: list[int]) -> int:
        n = len(nums)
        left, right = 0, n - 1
        # 先排序
        new_nums = sorted(nums)
        # 寻找左子段
        while left < n:
            if nums[left] != new_nums[left]:
                break
            left += 1

        if left == n:
            return 0

        # 寻找右子段
        while right > left:
            if nums[right] != new_nums[right]:
                break
            right -= 1

        return right - left + 1
```

