---
title: "15三数之和"
date: 2020-08-24T23:02:44+08:00
tags: ["leetcode"]
keywords: 
- leetcode
- 数组
categories: ["leetcode","数组"]
draft: false
---

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)



给你一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？请你找出所有满足条件且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

 

**示例：**

```
给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```



**思路**

```
摘自https://leetcode-cn.com/problems/3sum/solution/man-hua-jue-bu-wu-ren-zi-di-xiang-kuai-su-kan-dong/
```

```
本题的暴力题解可以仿照二数之和，直接三层遍历，取和为 0 的三元组，并记录下来，最后再去重。但是作为一个有智慧的人，我们不能这么去做。
```

因为我们的目标是找数，当然使用指针的方式最简单。假若我们的数组为：

```
[-1, 0, 1, 2, -1, -4]
```

求解过程如下：首先我们先把数组排个序（原因一会儿说），排完序长这样：

![](https://pic.leetcode-cn.com/d4406e3661f9577169dcb55844357674eb028126928ba00e3959aa203f828a52-image.png)

因为我们要同时找三个数，所以采取`固定一个数，同时用双指针来查找另外两个数的方式。`所以初始化时，我们选择固定第一个元素（当然，这一轮走完了，这个蓝框框我们就要也往前移动），同时将下一个元素和末尾元素分别设上 left 和 right 指针。画出图来就是下面这个样子：

![](https://pic.leetcode-cn.com/28cc3bb8d64fa243ffe5db78a716e21d1e2ddea22119ee10448141488e5a24a1-image.png)

现在已经找到了三个数，当然是计算其三值是否满足三元组。但是这里因为我们已经排好了序，如果**固定下来的数（上面蓝色框框）本身就大于 0，那三数之和必然无法等于 0 **。比如下面这种：

![](https://pic.leetcode-cn.com/cdb4439d84fc88c1921c8c3996e2a49869890550cb6c2f610066a64fc1d75884-image.png)

然后自然用脚指头也能想到，我们需要移动指针。现在我们的排序就发挥出用处了，`如果和大于 0，那就说明 right 的值太大，需要左移。如果和小于 0，那就说明 left 的值太小，需要右移`。(上面这个思考过程是本题的核心) 整个过程如下图所示：

![](https://pic.leetcode-cn.com/6f1bb787c64bb1bf745307e18f55a1d36fd1127866e73b5974d14d24f94e48ae-image.png)

其中：在第 6 行时，因为三数之和大于 0，所以 right 进行了左移。最后一行，跳过了重复的 -1。

然后啰嗦一句，因为我们需要处理重复值的情况。除了固定下来的i值（蓝框框），left 和 right 当然也是需要处理重复的情况，所以对于 left 和 left+1，以及 right 和 right-1，我们都单独做一下重复值的处理。（其实没啥处理，就是简单的跳过）



**代码**

```
package main

import (
	"fmt"
	"sort"
)

func threeSum(nums []int) [][]int {
	sort.Ints(nums)

	var result [][]int

	length := len(nums)
	if length < 3 {
		return result
	}
	for index, value := range nums {
		if value > 0 {
			return result
		}
		if index > 0 && nums[index] == nums[index-1] {
			continue
		}
		left := index + 1
		right := length - 1
		for left < right {
			sum := nums[left] + nums[right] + value
			if sum == 0 {
				result = append(result, []int{value, nums[left], nums[right]})
				for left < right && nums[left] == nums[left+1] {
					left += 1
				}
				for left < right && nums[right] == nums[right-1] {
					right -= 1
				}
				left += 1
				right -= 1
			} else if sum < 0 {
				left += 1
			} else {
				right -= 1
			}
		}

	}
	return result
}

func main() {
	nums := []int{-1, 0, 1, 2, -1, -4}
	result := threeSum(nums)
	fmt.Print(result)
}

```

