# [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`



## 解题思路

```
动态规划
```

> 这道题可以换一种表述：给定一个只包含正整数的非空数组 nums[0]，判断是否可以从数组中选出一些数字，使得这些数字的和等于整个数组的元素和的一半。因此这个问题可以转换成「0-1 背包问题」。这道题与传统的「0-1 背包问题」的区别在于，传统的「0-1 背包问题」要求选取的物品的重量之和不能超过背包的总容量，这道题则要求选取的数字的和恰好等于整个数组的元素和的一半。类似于传统的「0-1 背包问题」，可以使用动态规划求解。
>

在使用动态规划求解之前，首先需要进行以下判断。

- 根据数组的长度 $n$ 判断数组是否可以被划分。如果 $n<2$，则不可能将数组分割成元素和相等的两个子集，因此直接返回 $False$。
- 计算整个数组的元素和 $sum$ 以及最大元素 $maxNum$。如果$sum$ 是奇数，则不可能将数组分割成元素和相等的两个子集，因此直接返回 $False$。如果 $sum $是偶数，则令$target=sum//2$ ，需要判断是否可以从数组中选出一些数字，使得这些数字的和等于$target$。如果$maxNum>target$，则除了 $maxNum$ 以外的所有元素之和一定小于 $target$，因此不可能将数组分割成元素和相等的两个子集，直接返回$False$。



创建二维数组 $dp$，包含 $n$ 行$target+1$ 列，其中 $dp[i][j] $表示从数组的$ [0,i] $下标范围内选取若干个正整数（可以是 $0$ 个），**是否存在一种选取方案使得被选取的正整数的和等于$ j$**。初始时，$dp$ 中的全部元素都是 $False$

在定义状态之后，需要考虑边界情况。以下两种情况都属于边界情况。

- 如果不选取任何正整数，则被选取的正整数等于 $0$。因此对于所有 $0≤i<n$，都有 $dp[i][0]=true$。


- 当 $i=0$ 时，只有一个正整数 $nums[0]$ 可以被选取，因此 $dp[0][nums[0]]=true$。




对于$ i>0$ 且 $j>0$ 的情况，如何确定 $dp[i][j]$ 的值？需要分别考虑以下两种情况。

- 如果$j>=nums[i]$，则对于当前的数字$nums[i]$，可以选取也可以不选取，两种情况只要有一个为 True，就有$dp[i][j]=True$。

  - 如果不选$nums[i]$，则$dp[i][j] = dp[i-1][j]$
  - 如果选$nums[i]$，则$dp[i][j] = dp[i-1][j-nums[i]]$

- 如果$j<nums[i]$，则对选择的数字的和等于$j$的情况下无法选取当前的数字$nums[i]$，则$dp[i][j] = dp[i-1][j]$

状态转移方程：

```
dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]], j >= nums[i]
dp[i][j] = dp[i-1][j], j < nums[i]
```

![](https://assets.leetcode-cn.com/solution-static/416/1.png)

![](https://assets.leetcode-cn.com/solution-static/416/2.png)

![](https://assets.leetcode-cn.com/solution-static/416/3.png)

![](https://assets.leetcode-cn.com/solution-static/416/4.png)

![](https://assets.leetcode-cn.com/solution-static/416/5.png)

![](https://assets.leetcode-cn.com/solution-static/416/6.png)

![](https://assets.leetcode-cn.com/solution-static/416/7.png)

![](https://assets.leetcode-cn.com/solution-static/416/8.png)

![](https://assets.leetcode-cn.com/solution-static/416/9.png)

![](https://assets.leetcode-cn.com/solution-static/416/10.png)

![](https://assets.leetcode-cn.com/solution-static/416/11.png)

![](https://assets.leetcode-cn.com/solution-static/416/12.png)





```python
class Solution:
    def canPartition(self, nums: list[int]) -> bool:
        # 根据数组的长度 n 判断数组是否可以被划分。
        # 如果 n<2，则不可能将数组分割成元素和相等的两个子集，因此直接返回 False。
        n = len(nums)
        if n < 2:
            return False

        # 计算整个数组的元素和 sum, 如果sum是奇数，则不可能将数组分割成元素和相等的两个子集，
        # 因此直接返回 False
        total = sum(nums)
        if total % 2 != 0:
            return False

        # 获取最大元素max_num, 如果max_num > total // 2, 返回False
        W = total // 2
        if max(nums) > W:
            return False

        dp = [[False] * (W + 1) for _ in range(n)]
        for i in range(n):
            dp[i][0] = True

        for i in range(1, n):
            num = nums[i]
            for j in range(1, W + 1):
                if j >= num:
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - num]
                else:
                    dp[i][j] = dp[i - 1][j]

        return dp[n - 1][W]
```

