# [494. 目标和](https://leetcode.cn/problems/target-sum/)

难度中等1312

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

 

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**示例 2：**

```
输入：nums = [1], target = 1
输出：1
```

 

**提示：**

- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`

通过次数253,455

提交次数515,939





## 思路

下面介绍两种通用的解决此类问题的方法：

方法一：回溯
方法二：动态规划

##### 回溯

数组$nums$的每个元素都可以添加字符$+$和$-$，因此每个元素有$2$种添加符号的方法。当$n$个元素都添加符号之后，即得到一种表达式，如果表达式的结果等于目标数$target$，则该表达式即为符合要求的表达式。

可以使用回溯的方法遍历所有的表达式，回溯过程中维护一个计数器$count$，当遇到一种表达式的结果等于目标数$target$时，将$count$的值加$1$。遍历完所有的表达式之后，即可得到结果等于目标数$target$的表达式数目。

```python
class Solution:
    def findTargetSumWays(self, nums, target: int) -> int:
        count = 0

        def backtrack(index, total):
            # 递归完数组，不满足目标和，直接返回
            if index == len(nums) and total != target:
                return
            # 递归完数组，满足目标和，可行解 +1
            if index == len(nums) and total == target:
                nonlocal count
                count += 1
                return

            # 处理当前元素 nums[index]
            # 选择 +
            total += nums[index]
            # 递归处理下一个元素
            backtrack(index + 1, total)
            # 撤销选择
            total -= nums[index]

            # 选择 -
            total -= nums[index]
            backtrack(index + 1, total)
            # 撤销选择
            total += nums[index]

        backtrack(0, 0)
        return count
```

**超时了！！！**但Java用这种方式没有问题！！！



**参考链接：**

- https://leetcode.cn/problems/target-sum/solution/by-lfool-nerv/





**动态规划**

题目分析：

记数组的元素和为 $total$，添加 $+$ 号的元素之和为$ pos$，添加 $-$ 号的元素之和为 $neg$，则有以下关系：

$$
\begin{cases} pos + neg = total \\ pos - neg = target \end{cases}
$$
进一步可得：
$$
\begin{cases} pos = (total + target) / 2 \\ neg = (total - target) / 2 \end{cases}
$$
**问题转化：**
此时不难发现，本题实质上是一道「0-1 背包问题」：给定一个只包含正整数的非空数组 $nums$，判断是否可以从数组中选出一些数字（每个元素最多选一次），使得选出的这些数字的和刚好等于 $pos$ 或者 $neg$。

**「0-1 背包问题」一般形式：**
动态规划是解决「0−1 背包问题」的标准做法。一般地，我们定义：`dp[i][j] `表示前` i` 件物品放入一个容量为 `j` 的背包可以获得的最大价值，则状态转移过程可表示为：

- 不选择第 `i` 件物品：问题转化为了前 `i-1` 件物品放入容量为` j`的背包中所获得的价值：
  $$
  dp[i][j] =dp[i-1][j]dp[i][j]=dp[i−1][j] ；
  $$

- 选择第` i`件物品：第`i `件物品占据容量$w_i$ ，前` i-1` 件物品放入剩下的容量为$ j-w_i$ 的背包中，问题也就转化为了前	` i-1`	 件物品放入容量为 的$ j-w_i$ 背包中所获得的价值$dp[i-1][j-w_i]$加上要放入的第 `i` 件物品的价值$v[i]$
  $$
  dp[i][j] =dp[i-1][j-w_i] + v_i
  $$

两种情况取较大者：
$$
dp[i][j]=max{( dp[i−1][j],dp[i−1][j−w 
i
​
 ]+v 
i)

  } 
$$

> ⚠️ 求最优解的背包问题中，有的题目要求恰好装满背包时的最优解，有的题目则要求不超过背包容量时的最优解。一种区别这两种问法的实现方法是在状态初始化的时候有所不同。[
> 初始化的 $dp$ 数组事实上就是在背包中没有放入任何物品时的合法状态：
>
> 1. 如果要求恰好装满背包，那么在初始化时 $dp[i][0]=0$，其它 $dp[i][1,2,...,∗] $均设为$ -∞$。这是因为此时只有容量为 $0$ 的背包可能被价值为 $0$ 的 “恰好装满”，而其它容量的背包均没有合法的解，属于未定义的状态。
> 2. 如果只是要求不超过背包容量而使得背包中的物品价值尽量大，初始化时应将 $dp[*][*]$ 全部设为 $0$ 。这是因为对应于任何一个背包，都有一个合法解为 “什么都不装”，价值为 $0$。



**本题题目分析：**

对于本题而言，$nums[i]$则对应于常规背包问题中第$i$  件物品的重量。我们要做的是从数组 $nums$ 中选出若干个数字（每个元素最多选一次）使得其和刚好等于 $pos$ 或者 $neg$，并计算有多少种不同的选择方式。

**状态转移**

根据本题的要求，上述「0-1 背包问题」的状态转移方程（1）可修改为：
$$
dp[i][j]=dp[i−1][j] + dp[i−1][j−nums[i]] 
$$
**初始化**

记数组 $nums$ 的长度为 $n$。为便于状态更新，减少对边界的判断，初始二维 $dp$ 数组维度为$ {(n+1) \times (*)}$，其中第一维为 $n+1$也意味着：第 $i$ 个数字为$ nums[i-1]$，第$ 1$ 个数字为 $nums[0]$，第 $0$ 个数字为空。

初始化时：

- $dp[0][0] = 1$：表示从前 00 个数字中选出若干个数字使得其和为 $0$ 的方案数为 $1$，即「空集合」不选任何数字即可得到 $0$。

- 对于其他 $dp[0][j],\ \ j\geq 1$，则有 $dp[0][j] = 0：$「空集合」无法选出任何数字使得其和为$ j\geq 1$。

  > $dp[i][0] = 1$ 在程序迭代实现中已有体现，在此无需提前重复定义。

  

https://leetcode.cn/problems/YaVDxD/solution/jia-jian-de-mu-biao-zhi-by-leetcode-solu-be5t/

```
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        # x + y = sum  
        # x - y = target
        # --> 2 * x = sum + target
        # 用01背包
        n = len(nums)

        tot_sum = sum(nums)
        if (tot_sum + target) % 2 == 1:
            return 0
        ttt = (tot_sum + target) // 2
        if ttt < 0:
            return 0

        #---- 01背包
        dp = [0 for _ in range(ttt + 1)]
        dp[0] = 1
        for i in range(n):
            y = nums[i]
            for t in range(ttt, y - 1, -1):
                x = t - y
                dp[t] += dp[x]

        return dp[ttt]
```

