# [剑指 Offer II 103. 最少的硬币数目](https://leetcode-cn.com/problems/gaM7Ch/)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

 

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

**示例 4：**

```
输入：coins = [1], amount = 1
输出：1
```

**示例 5：**

```
输入：coins = [1], amount = 2
输出：2
```

**提示：**

```
1 <= coins.length <= 12
1 <= coins[i] <= 231 - 1
0 <= amount <= 104
```



## 思路

**动态规划**

```
动态规划问题建模
设硬币面值为 value [1,3,5]，总额为 sum，硬币个数为 coin
```

| 总额    | 硬币1元 | 硬币3元 | 硬币5元 |
| ------- | ------- | ------- | ------- |
| 凑够0元 | 0       | 0       | 0       |
| 凑够1元 | 1       | 0       | 0       |
| 凑够2元 | 2       | 0       | 0       |
| 凑沟3元 | 0       | 1       | 0       |
| 凑够4元 | 1       | 1       | 0       |
| 凑够5元 | 0       | 0       | 1       |
| 凑够6元 | 1       | 0       | 1       |
| 凑够7元 | 2       | 0       | 1       |
| 凑够8元 | 0       | 1       | 1       |

```
规律
0元 = 0
1元 = （1-1）元硬币数 + 1 = 0 + 1 = 1
2元 = （2-1）元硬币数 + 1 = 1 + 1 = 1
3元 = min（（3-1）元硬币数 + 1， （3-3）元硬币数 + 1） = min(2+1, 0+1) = 1
4元 = min（（4-1）元硬币数 + 1， （4-3）元硬币数 + 1） = min(1+1, 1+1) = 2
...
8元 = min（（8-1）元硬币数 + 1， （8-3）元硬币数 + 1， （8-5）元硬币数+1）= .。。。

由此可见，只需要存储前面的最小硬币数，就可推出后面的最小硬币数
```



**最优子结构：**
`由于有三种面值 1，3，5，所以凑够 11 元有三种方案（选最小值）
11 元硬币数 = min ((11-1) 元硬币数 + 1, (11-3) 元硬币数 + 1, (11-5) 元硬币数 + 1 )`

**状态转移方程：以硬币面值[1,3,5]为例**

```
dp[11] = min(dp[11-1] +1, dp[11-3] + 1, dp[11-5] + 1)
```

**所以动态规划**

```
dp[i]表示组成i所需的最小硬币数
dp[i] = min(dp[i], dp[i-coin] + 1) # coin代表多少元
dp[0] = 0
```

```
class Solution:
    def coinChange(self, coins, amount: int) -> int:
        dp = [float("inf")] * (amount + 1)
        dp[0] = 0
        # 循环硬币面值 1 3 5
        for coin in coins:
            # 循环总额，即迭代表格每一层
            for i in range(coin, amount+1):
                dp[i] = min(dp[i], dp[i - coin] + 1)

        return dp[-1] if dp[-1] != float('inf') else -1



```

