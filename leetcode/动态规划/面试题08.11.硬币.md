# [面试题 08.11. 硬币](https://leetcode-cn.com/problems/coin-lcci/)

硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

**示例1:**

```
 输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
5=5
5=1+1+1+1+1
```

**示例2:**

```
 输入: n = 10
 输出：4
 解释: 有四种方式可以凑成总金额:
10=10
10=5+5
10=5+1+1+1+1+1
10=1+1+1+1+1+1+1+1+1+1
```

**说明：**

```
注意:

你可以假设：

0 <= n (总金额) <= 1000000
```



## 思路

**动态规划：完全背包问题**

动态规划思想是希望连续的，也就是说上一个状态和下一个状态(自变量)之间有关系而且连续。

> 因为硬币给定的数量是无限的，所以可以将该问题转换为完全背包问题。

**套用完全背包模板：即数组中的元素可重复使用，coins 数组放在外循环，n（背包容量）在内循环。且内循环正序。**

> 把 01 背包的逆序更新换成顺序更新，就可以解决放几个的问题，把所有还可以放的状态都更新一遍，从左向右进行更新，如果前面的状态就已经放得下一个了，那么基于这个状态的另一个状态还可以再放一个，所以就基于上个状态继续更新，因而是正序更新。
>

因为硬币值分别为：25 分、10 分、5 分、1 分，所以所拥有的硬币数组为 coins = [25, 10, 5, 1]，并且背包的容量为 n。

```
dp[j]:表示背包容量为j时，共有dp[j]种表示方法

由于该题是求组合数，遍历coins数组（选或不选）：
-- 若当前遍历的硬币要被选择时（当前遍历的硬币值 <= 当前背包容量），则此时背包容量减少coins[i]，此时满足背包容量j的方法数要加上背包容量为j-coins[i]的方法数，此时状态转移方程：dp[j] = dp[j] + dp[j-coins[i]]
-- 若当前遍历的硬币不被选择时（当前遍历的硬币值>当前背包容量），此时组成背包容量j的方法数不变，不需要进行任何操作
```

```
dp[0]=1，当背包容量为 0 时，只有一种方法能够凑出 0 元，就是一个硬币也不选。
```

> 注意：由于结果可能会很大，所以需要将结果模上 1000000007，不只是在最后返回的时候取模，在 for 循环的计算中，也需要将结果取模。
>



```
class Solution:
    def waysToChange(self, n: int) -> int:
        coins = [1, 5, 10, 25]
        dp = [0] * (n + 1)

        # dp[j] = dp[j] + dp[j-coins[i]]
        # dp[]
        dp[0] = 1

        for i in range(4):
            for j in range(coins[i], n+1):
                dp[j] = (dp[j] + dp[j - coins[i]]) % 1000000007

        return dp[n] % 1000000007


s = Solution()
res = s.waysToChange(5)
print(res)

```

