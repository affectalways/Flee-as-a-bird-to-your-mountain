# [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

难度中等522

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

 

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
解释：
40-33=7
33-26=7
21-
```

 

**提示：**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`



## 思路

> 参考链接：https://leetcode.cn/problems/last-stone-weight-ii/solution/bei-bao-wen-ti-he-ji-python-ni-de-bei-ba-za7b/

> 提示：不就是所有的石头相互加减得到的大于等于0的最小值，最后答案应该也是给每个石头都附上正负号的后的最小非负数

将问题转化为背包问题来解决。

若可以将石头分成重量相等的两堆，则可以将所有石头粉碎，没有石头剩下。所以要找到最后一块石头的最小重量，就要尽量将石头分成重量相等的两份。

> 实际上就是把石块分为两堆：一堆为正，一堆为负：正的和减去负的和 如果正负堆重量相等，即为0
>
> 将一堆stone放进最大容量为sum//2的背包,求放进去的石头的最大重量dp[-1],最终答案即为sum-2*dp[-1]
> 类似[494. 目标和](https://leetcode.cn/problems/target-sum/solution/by-flix-rkb5/)

- - 



对于该问题，定义二维布尔数组 $dp$，其中 $dp[i+1][j]$ 表示前 $i$个石头能否凑出重量 $j$。特别地，$dp[0][] $为不选任何石头的状态，因此除了 $dp[0][0]$ 为真，其余 $dp[0][j]$全为假。

对于第$ i$ 个石头，考虑凑出重量$ j$：

- 若 $j<stones[i]$，则不能选第$ i$ 个石头，此时有 $dp[i+1][j]=dp[i][j]$；
- 若$ j≥stones[i]$，存在选或不选两种决策，不选时有 $[j]dp[i+1][j]=dp[i][j]$，选时需要考虑能否凑出重量$j−stones[i]$，即 $dp[i+1][j]=dp[i][j−stones[i]]$。若二者均为假则 $dp[i+1][j] 为假$，否则 $dp[i+1][j] $为真。

因此状态转移方程如下：

$$
\textit{dp}[i+1][j]= \begin{cases} \textit{dp}[i][j],& j<\textit{stones}[i] \\ \textit{dp}[i][j] \lor \textit{dp}[i][j-\textit{stones}[i]], & j\ge \textit{stones}[i] \end{cases}
$$


其中 $∨$ 表示逻辑或运算。求出$dp[n][] $后，所有为真的 $dp[n][j] $中，最大的 $j$ 即为 能取到的最大值。代入 $sum−2⋅neg$ 中即得到最后一块石头的最小重量。



```python
class Solution:
    def lastStoneWeightII(self, stones) -> int:
        total = sum(stones)
        target = total // 2
        n = len(stones)
        dp = [[False] * (target + 1) for _ in range(n + 1)]
        dp[0][0] = True

        for i in range(n):
            for j in range(target + 1):
                if j < stones[i]:
                    dp[i + 1][j] = dp[i][j]
                else:
                    dp[i + 1][j] = dp[i][j] or dp[i][j - stones[i]]

        ans = None
        for j in range(target, -1, -1):
            if dp[n][j]:
                ans = total - 2 * j
                break

        return ans
```





**优化时间复杂度的代码**

就先计算石头的总重量，再除以2作为背包的最大容量，通过背包问题找出该容量下的背包可以装的最大容量的石头。

将stones作为背包问题里的weight和value

- 确定dp数组的定义：
  - **dp[i]为当背包容量为i时，可以分到的重量最大的石头。**
- 确定递推公式：
  - 在不加入stone[i]的石头重量dp[j]和加入stone[i]的重量中选最大的。
- 确定数组初始化：
  - 因为石头重量为正整数，初始化为0即可。

- 确定遍历方式：
  - 外层循环遍历每个石头，内层循环倒序遍历背包。



```python
class Solution:
    def lastStoneWeightII(self, stones) -> int:
        total = sum(stones)
        target = total // 2
        # dp[i]为容量大小为[i]的背包内石块的重量
        dp = [0 for _ in range(target + 1)]
        # print(dp)
        for stone in stones:
            # print(stone)
            for i in range(stone, target + 1):
            for i in range(target, stone - 1, -1):
                dp[i] = max(dp[i], dp[i - stone] + stone)
                # print(dp)

        return total - 2 * dp[-1]
```

