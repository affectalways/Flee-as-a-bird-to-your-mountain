# [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

难度中等786

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

 

**示例 1：**

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

**示例 2：**

```
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

 

**提示：**

- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` 仅由 `'0'` 和 `'1'` 组成
- `1 <= m, n <= 100`





## 思路

> 动态规划（0-1背包问题）

这道题和经典的背包问题非常相似，但是和经典的背包问题只有一种容量不同，这道题有两种容量，即选取的字符串子集中的 $0$ 和 $1$ 的数量上限。

经典的背包问题可以使用二维动态规划求解，两个维度分别是物品和容量。这道题有两种容量，因此需要使用三维动态规划求解，三个维度分别是字符串、$0 $的容量和$1 $的容量。

定义三维数$dp$，其中 $p[i][j][k]$ 表示在前 $i$ 个字符串中，使用$j $ 个$0$ 和$k $个 $1 $的情况下最多可以得到的字符串数量。假设数组 $str $的长度为$ l$，则最终答案为 $dp[l][m][n]$。

当没有任何字符串可以使用时，可以得到的字符串数量只能是 $0$，因此动态规划的边界条件是：当$ i=0$ 时，对任意 $0≤j≤m$ 和 $0≤k≤n$，都有 $dp[i][j][k]=0$。

当 $1≤i≤l $时，对于 $strs $中的第 $i$个字符串（计数从 $1$ 开始），首先遍历该字符串得到其中的 $0$ 和 $1$ 的数量，分别记为 $zeros$ 和 $ones$，然后对于 $0≤j≤m$ 和$0≤k≤n$，计算 $dp[i][j][k] $的值。

当 $0$ 和 $1 $的容量分别是$j$和 $k$ 时，考虑以下两种情况：

- 如果 $j<zeros$ 或 $k<ones$，则不能选第 $i$ 个字符串，此时有 $dp[i][j][k]=dp[i−1][j][k]$；
- 如果$j≥zeros$ 且$k≥ones$，则如果不选第 $i$ 个字符串，有 $dp[i][j][k]=dp[i−1][j][k]$，如果选第 $i$ 个字符串，有 $dp[i][j][k]=dp[i−1][j−zeros][k−ones]+1$，$dp[i][j][k] $的值应取上面两项中的最大值。

因此状态转移方程如下：

因此状态转移方程如下：

$$
\textit{dp}[i][j][k]=\begin{cases} \textit{dp}[i - 1][j][k], & j<\textit{zeros} ~~ | ~~ k<\textit{ones} \\ \max(\textit{dp}[i - 1][j][k], \textit{dp}[i - 1][j - \textit{zeros}][k - \textit{ones}] + 1), & j \ge \textit{zeros} ~ \& ~ k \ge \textit{ones} \end{cases}
$$
最终得到 $dp[l][m][n] $的值即为答案。

由此可以得到空间复杂度为 O(lmn)的实现。

```python
class Solution:
    def findMaxForm(self, strs: list[str], m: int, n: int) -> int:
        length = len(strs)
        dp = [[[0 for _ in range(n + 1)] for _ in range(m + 1)] for _ in range(length + 1)]
        # 注意：有一位偏移
        for i in range(1, length + 1):
            # 计算0、1数量
            zeros = strs[i - 1].count('0')
            ones = strs[i - 1].count('1')

            for j in range(m + 1):
                for k in range(n + 1):
                    dp[i][j][k] = dp[i - 1][j][k]
                    if j >= zeros and k >= ones:
                        dp[i][j][k] = \
                            max(dp[i][j][k],
                                dp[i - 1][j - zeros][k - ones] + 1)

        return dp[length][m][n]

```

