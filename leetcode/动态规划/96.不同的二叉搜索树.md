# [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

 

**示例 1：**

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

**提示：**

```
1 <= n <= 19
```





## 解题思路

**人菜瘾大**

**动态规划**，抄袭[官方解题思路](https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/)

给定一个有序列$1...n$，为了构建出一棵二叉搜索树，我们可以遍历每个数字$i$，将该数字作为树根，将$1..（i-1）$序列作为左子树，将$（i+1）...n$序列作为右子树。

在上述构建过程中，由于根的值不通，因此可以保证每棵二叉搜索树是唯一的。

由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此可以使用动态规划来求解本题。

**算法**

题目求得是计算不同二叉搜索树的个数。因此我们可以定义两个函数：

- $G(n)$：长度为$n$的序列能构成的不同二叉搜索树的个数
- $F(i,n)$：以$i$为根、序列长度为$n$的不同二叉搜索树个数$（1<=i <=n）$

$G(n)$是需要求解的函数



**举例**

创建以3为根、长度为7的不同二叉搜索树，整个序列是`[1, 2, 3, 4, 5, 6, 7]`，我们需要从左子序列 `[1, 2]` 构建左子树，从右子序列 `[4, 5, 6, 7]` 构建右子树，然后将它们组合（即笛卡尔积）。

对于这个例子，不同二叉搜索树的个数为 F(3, 7)。我们将` [1,2]` 构建不同左子树的数量表示为 G(2), 从 `[4, 5, 6, 7]` 构建不同右子树的数量表示为 G(4)。于是，F(3,7) = G(2) * G(4)。 因此，我们可以得到以下公式：

$$
F(i,n)=G(i−1)⋅G(n−i)
$$


对于边界情况，当序列长度为 $1$（只有根）或为 $0$（空树）时，只有一种情况，即：

$$
G(0) = 1, \qquad G(1) = 1
$$


G(n) 的递归表达式：

$$
G(n) = \sum_{i=1}^{n}G(i-1) \cdot G(n-i) \qquad \qquad (3)
$$


**代码**

```python
class Solution:
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        G = [0]*(n+1)
        G[0], G[1] = 1, 1

        for i in range(2, n+1):
            for j in range(1, i+1):
                G[i] += G[j-1] * G[i-j]

        return G[n]
```

或

#### 数学方法

```python
class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        C = 1
        for i in range(0, n):
            C = C * 2*(2*i+1)/(i+2)
        return int(C)

```

