# [剑指 Offer II 092. 翻转字符](https://leetcode.cn/problems/cyJERH/)

难度中等37

如果一个由 `'0'` 和 `'1'` 组成的字符串，是以一些 `'0'`（可能没有 `'0'`）后面跟着一些 `'1'`（也可能没有 `'1'`）的形式组成的，那么该字符串是 **单调递增** 的。

我们给出一个由字符 `'0'` 和 `'1'` 组成的字符串 s，我们可以将任何 `'0'` 翻转为 `'1'` 或者将 `'1'` 翻转为 `'0'`。

返回使 s **单调递增** 的最小翻转次数。

 

**示例 1：**

```
输入：s = "00110"
输出：1
解释：我们翻转最后一位得到 00111.
```

**示例 2：**

```
输入：s = "010110"
输出：2
解释：我们翻转得到 011111，或者是 000111。
```

**示例 3：**

```
输入：s = "00011000"
输出：2
解释：我们翻转得到 00000000。
```

 

**提示：**

- `1 <= s.length <= 20000`
- s 中只包含字符 `'0'` 和 `'1'`

 

注意：本题与主站 926 题相同： https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/



## 思路

**动态规划**

单调递增的字符串满足以下性质：

- 首个字符是 $0$ 或 $1$；
- 其余的每个字符，字符 $0$  前面的相邻字符一定是  $0$ ，字符 $1$前面的相邻字符可以是  $0$  或 $1$。


当$ i > 0$ 时，如果字符串 $s$ 的长度为 $i$ 的前缀即 $s[0 .. i - 1]$ 单调递增，且 $s[i]$ 和 $s[i - 1]$也满足上述单调递增的顺序，则长度为$ i + 1$的前缀$s[0..i]$也单调递增。因此可以使用动态规划计算使字符串 $s$ 单调递增的最小翻转次数。

由于字符串 $s$ 的每个位置的字符可以是   $0$  或 $1$，因此对于每个位置需要分别计算该位置的字符是  $0$  和该位置的字符是 $1$的情况下的最小翻转次数。



1. **确定dp数组以及下标的含义：**

   $dp[i][0]$和$dp[i][1]$分别表示下标$i$处的字符为 $0$ 和 $1$ 的情况下使得 $s[0..i]$单调递增的最小翻转次数。

   - $dp[i][0]$表示第$i$个字符是$0$的最小翻转次数
   - $dp[i][1]$表示第$i$个字符是$1$的最小翻转次数

   

2. **确定递推公式：**

   - 如果 $s[i] == 1$， $s[i-1]$是$0$或$1$才可以保持单调性
   - 如果 $s[i] == 0$，$s[i-1]$是$0$才可以保持单调性

   $$
   dp[i][0] = \begin{cases} dp[i-1][0],\quad\quad\quad s[i] = 0 \\
   		   dp[i-1][0] + 1, \quad s[i] = 1 \end{cases}
   $$

   $$
   dp[i][1] = \begin{cases}  min(dp[i-1][0], dp[i-1][1])+1,\quad\quad\quad\quad\quad\quad s[i] = 0 \\
   		   min(dp[i-1][0], dp[i-1][1]), \quad\quad\quad\quad\quad\quad\quad\quad s[i] = 1 \end{cases}
   $$

   

3. **初始状态：**

   - $dp[i][0] = dp[i][1] = 0$

   

4. **返回值：**

   - $dp[i][0]$和$dp[i][1]$中间的最小值



```python
class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        n = len(s)
        dp0, dp1 = [0 for _ in range(n)], [0 for _ in range(n)]
        for i in range(1, n):
            if s[i] == '0':
                dp0[i] = dp0[i - 1]
                dp1[i] = min(dp0[i-1], dp1[i-1]) + 1
            else:
                dp0[i] = dp0[i - 1] + 1
                dp1[i] = min(dp0[i-1], dp1[i-1])

        return min(dp0[-1], dp1[-1])
```

