# [1884. 鸡蛋掉落-两枚鸡蛋](https://leetcode-cn.com/problems/egg-drop-with-2-eggs-and-n-floors/)

给你 2 枚相同 的鸡蛋，和一栋从第 1 层到第 n 层共有 n 层楼的建筑。

已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都 会碎 ，从 f 楼层或比它低 的楼层落下的鸡蛋都 不会碎 。

每次操作，你可以取一枚 没有碎 的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。

请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？

**示例 1：**

```
输入：n = 2
输出：2
解释：我们可以将第一枚鸡蛋从 1 楼扔下，然后将第二枚从 2 楼扔下。
如果第一枚鸡蛋碎了，可知 f = 0；
如果第二枚鸡蛋碎了，但第一枚没碎，可知 f = 1；
否则，当两个鸡蛋都没碎时，可知 f = 2。
```

**示例 2：**

```
输入：n = 100
输出：14
解释：
一种最优的策略是：

将第一枚鸡蛋从 9 楼扔下。如果碎了，那么 f 在 0 和 8 之间。将第二枚从 1 楼扔下，然后每扔一次上一层楼，在 8 次内找到 f 。总操作次数 = 1 + 8 = 9 。

如果第一枚鸡蛋没有碎，那么再把第一枚鸡蛋从 22 层扔下。如果碎了，那么 f 在 9 和 21 之间。将第二枚鸡蛋从 10 楼扔下，然后每扔一次上一层楼，在 12 次内找到 f 。总操作次数 = 2 + 12 = 14 。

如果第一枚鸡蛋没有再次碎掉，则按照类似的方法从 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99 和 100 楼分别扔下第一枚鸡蛋。
不管结果如何，最多需要扔 14 次来确定 f 。
```

**提示：**

```
1 <= n <= 1000
```



## 思路

**动态规划**

如果只有一个鸡蛋的话，没别的办法，策略只能是暴力枚举，从第1层到第n层一路往上尝试，哪一层碎了，那它的下一层就是我们要找的答案k。

现在是两个鸡蛋，情况变得复杂了很多。
可以二分求解嘛？最坏情况下的最优解，似乎这样听起来很像二分，但是鸡蛋碎了就没了这件事彻底断了二分的后路，因为二分对于200层来说，要尝试log2(200)次，没法二分。

但是留步！二分这里还可以思考一下。假设第一个鸡蛋随手在第X层一扔，有两种情况：
如果没碎，那么说明答案k存在于[X, 200]之间。此时还是有两个鸡蛋，但题目的范围大大缩小了。

如果碎了，那么说明答案k存在于[1, X)之间。此时只剩一个鸡蛋。

考虑最优策略，就要面对所有的情况，第2种情况下鸡蛋碎了，此时只剩1个鸡蛋，范围在1到X，那么根据前面的结论，为了确保我们能够得到答案，在只有1个鸡蛋的情况下，只能从1层开始往上暴力枚举。

所以会发现，面试中的2个鸡蛋还是有目的性的，**第1个用来尝试，缩小范围。第2个鸡蛋用来暴力求解**。

此时想到1个方法，第1一个鸡蛋在第100层扔，将200层分为2份。不碎的话，就往150层扔，然后175层，依次类推。
但是碎了的话呢？只剩1个鸡蛋了，只能从1扔到99层。
所以上述直观方法，最差情况下的答案是楼层K为99，你一共扔了1 + 98 = 99次。

从答案上来说 1和 98有一些不平衡啊，有没有更好的方法？
换一个数，可不可以增加前面的1，减少后面的98，从而让最终结果更少一点。举个例子，第1次扔鸡蛋在第20楼，之后的策略是一直往上递增20楼。
第1次就碎了的话就太好了，第2个鸡蛋从1层开始往上尝试，最多到18楼。
第1次没碎的话，下一次扔40楼，还没碎的话就扔60楼，80楼，100楼，120楼直到200楼。(如果到200楼还没碎，那就无解了哈哈。原则上是不需要测200楼的)。假设说第200楼碎了，第2个鸡蛋要从181楼开始往上暴力到198层即可。



**使用二维动态规划，状态定义为：**

- dp`[i][0]`表示只有一颗蛋时，检测i层楼所需要的最小操作次数

- `dp[i][1]`表示有两颗蛋时，检测i层楼所需要的最小操作次数

**当要求解检测i层楼最少需要多少操作次数(dp[i])时:**

- 手里只有一颗蛋的情况(`dp[i][0]`)：

  只有一颗蛋，而要来检测i层楼，只能一层一层来丢。

  `即：dp[i][0] = i`

- 手里有两颗蛋的情况(`dp[i][1]`):

  现在有两颗蛋来检测i层楼，可以不用像之前那样一层一层丢了，我们这次先选择i层中的某一层来丢第二颗蛋，借投蛋的结果来排除掉部分楼层。

  **假设选择第k层(1<=k<=i)来丢第二个蛋：**

  - 如果在k层碎了蛋：`dp[i][1] = dp[k-1][0] + 1`
    因为在第k层碎了蛋，说明第k层以上的楼层都会碎，我们只需要再检测k层以下的楼层。
    此时我们只剩一个蛋了，还剩k-1层楼需要检测，因此状态从用一个蛋来检测k-1层的最小操作次数(`dp[k-1][0]`)进行转移。

  - 如果在k层没碎：`dp[i][1] = dp[i-k][1] + 1`
    因为蛋在第k层没碎，说明第k层以下的楼层都不会碎，我们只需要再检测k层以上的楼层。
    此时我们还有两个蛋，剩i-k层楼需要检测，因此状态从用两个蛋来检测i-k层的最小操作次数(`dp[i-k][1]`)进行转移。

  - **综上，若选择在第k层丢第二个蛋：`dp[i][1] = max(dp[k-1][0],dp[i-k][1])+1`**

    因为需要保证检测成功。即无论蛋是否在第k层碎掉都要完成检测。

    

而求解`dp[i`][1]，我们要找一个能让操作次数最小的第`k`层来把第二个蛋丢下去。
即：

```
dp[i][1] = min(dp[i][1],max(dp[k-1][0],dp[i-k][1])+1) 1<=k<=i
```



```
class Solution:
    def twoEggDrop(self, n: int) -> int:
        '''
        dp[i][0]表示只有一颗蛋去检测i层楼需要的最小次数；
        dp[i][1]表示有两颗蛋去检测i层楼需要的最小次数。
        '''
        dp = [[float('inf')] * 2 for _ in range(n + 1)]
        dp[0] = [0, 0]
        for i in range(1, n + 1):
            dp[i][0] = i
            for k in range(1, i + 1):
                dp[i][1] = min(dp[i][1], max(dp[k - 1][0], dp[i - k][1]) + 1)
                
        return dp[n][1]


```

