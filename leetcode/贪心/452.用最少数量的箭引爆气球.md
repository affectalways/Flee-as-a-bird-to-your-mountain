# [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

难度中等650

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足  `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

**示例 1：**

```
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。
```

**示例 2：**

```
输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
解释：每个气球需要射出一支箭，总共需要4支箭。
```

**示例 3：**

```
输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
解释：气球可以用2支箭来爆破:
- 在x = 2处发射箭，击破气球[1,2]和[2,3]。
- 在x = 4处射出箭，击破气球[3,4]和[4,5]。
```

 



**提示:**

- `1 <= points.length <= 105`
- `points[i].length == 2`
- `-231 <= xstart < xend <= 231 - 1`





## 思路

```
排序+贪心
```

以`[[10,16],[2,8],[1,6],[7,12]]`为例

1. 先按照数组的左节点进行排序，排序后的结果为`[[1, 6], [2, 8], [7, 12], [10, 16]]`
2. 开始遍历子数组，遍历的目的是查找重叠数组
3. 找到重叠数组，但是该怎么区分用在哪射箭？![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/452.png)
4. 如上图，获取重叠气球中右边边界的最小值，如`[1, 6], [2, 8]`，重叠右边界最小为6，因为`[7, 12]`中的7>6，所以不能用同一只箭，需要继续遍历

```python
class Solution:
    def findMinArrowShots(self, points: list[list[int]]) -> int:
        # 排序
        points.sort()

        ans = 1
        n = len(points)
        # 获取第一个数组的右边界
        min_right = points[0][1]

        # 遍历
        for i in range(1, n):
            # 如果两个数组有部分重合，更新右边界为小的那个
            if points[i][0] <= min_right:
                min_right = min(min_right, points[i][1])
                continue

            # 如果两个数组不重合，箭数+1, 并更新右边界为当前数组的右边界
            ans += 1
            min_right = points[i][1]

        return ans
```

