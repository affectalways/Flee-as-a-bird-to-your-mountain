# [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

 

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。


```

**示例 2:**

```
输入: nums = [2,3,0,1,4]
输出: 2
```

**提示:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`





## 思路

> ##### 贪心
>

我们的目标是到达数组的最后一个位置，因此我们可以考虑最后一步跳跃前所在的位置，该位置通过跳跃能够到达最后一个位置。

如果有多个位置通过跳跃都能够到达最后一个位置，那么我们应该如何进行选择呢？

可以「贪心」地选择距离最后一个位置最远的那个位置，也就是对应下标最小的那个位置。因此，我们可以从左到右遍历数组，选择第一个满足要求的位置。

> 从小到大遍历的原因是：position是从后往前走, 而正序遍历是选择下标最小的最大的步长，
>
> 只需想清楚一点：最小下标只要能被覆盖，最小下标后面的就能被覆盖
>
> 如果前面的步长连最小下标都不能被覆盖，最小下标后面的更不可能被覆盖

![45.跳跃游戏II](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/20201201232309103.png)

```python
class Solution:
    def jump(self, nums) -> int:
        position = len(nums) - 1
        # 记录走的最大步数
        step = 0
        while position:

            # 从小到大遍历的原因是：position是从后往前走,
            # 而正序遍历是选择下标最小的最大的步长，
            #
            # 只需想清楚一点：最小下标只要能被覆盖，最小下标后面的就能被覆盖
            # 如果最小下标都不能被覆盖，最小下标后面的更不可能被覆盖
            for i in range(position):
                # 计算当前坐标+移动步数是否>=当前下标
                if i + nums[i] >= position:
                    # 若>=当前下标, 当前下标移至当前坐标
                    position = i
                    # 移动步数+1
                    step += 1
                    # 跳出循环
                    break

        return step
```

