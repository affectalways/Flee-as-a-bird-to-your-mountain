#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

**提示：**

```
1 <= nums.length <= 6
-10 <= nums[i] <= 10
nums 中的所有整数 互不相同
```



### 回溯算法

```
class Solution:
    def permute(self, nums):
        import copy
        self.res = []
        self.length = len(nums)
        if not self.length:
            return self.res

        def _back_cur(already, exclude):
            if not exclude \
                    and already not in self.res:
                tmp = copy.deepcopy(already)
                self.res.append(tmp)
                return

            for j, v in enumerate(exclude):
                already.append(v)
                _back_cur(already, exclude[:j] + exclude[j + 1:])
                already.pop()
            return

        for i, val in enumerate(nums):
            _back_cur([val], nums[:i] + nums[i + 1:])

        return self.res
```

