# [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

难度中等785

给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。
```

**示例 2：**

```
输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
输出：5
```

 

**提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 100`

通过次数150,923

提交次数264,308



## 解题思路

本题要求我们计算两个数组的最长公共子数组。需要注意到数组长度不超过 1000，且子数组在原数组中连续。

容易想到一个暴力解法，即枚举数组 A 中的起始位置 i 与数组 B 中的起始位置 j，然后计算 A[i:] 与 B[j:] 的最长公共前缀 k。最终答案即为所有的最长公共前缀的最大值。

> 这里借用了 Python 表示数组的方法，A[i:] 表示数组 A 中索引 i 到数组末尾的范围对应的子数组。
>

这个过程的伪代码如下：

```
ans = 0
for i in [0 .. A.length - 1]
    for j in [0 .. B.length - 1]
        k = 0
        while (A[i+k] == B[j+k]) do   # and i+k < A.length etc.
            k += 1
        end while
        ans = max(ans, k)
    end for
end for

```

虽然该暴力解法的最坏时间复杂度为 `O(n*3)`，但通过观察该暴力解法，我们可以提出几个时间复杂度更优秀的解法。



##### 动态规划

提出动态规划的解法：令 `dp[i][j]` 表示 `A[i:] 和 B[j:] `的最长公共前缀，那么答案即为所有` dp[i][j] `中的最大值。如果 A[i] == B[j]，那么` dp[i][j] = dp[i + 1][j + 1] + 1`，否则` dp[i][j] = 0`。

这里借用了 Python 表示数组的方法，A[i:] 表示数组 A 中索引 i 到数组末尾的范围对应的子数组。

考虑到这里 `dp[i][j]` 的值从` dp[i + 1][j + 1]` 转移得到，所以我们需要倒过来，首先计算 `dp[len(A) - 1][len(B) - 1]`，最后计算 `dp[0`][0]。



拿示例1中，A: [1,2,3,2,1]，B: [3,2,1,4,7]为例，画一个dp数组的状态变化，如下：

![718.最长重复子数组](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/2021011215282060.jpg)

```python
class Solution:
    def findLength(self, A: List[int], B: List[int]) -> int:
        n, m = len(A), len(B)
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        ans = 0
        for i in range(n - 1, -1, -1):
            for j in range(m - 1, -1, -1):
                dp[i][j] = dp[i + 1][j + 1] + 1 if A[i] == B[j] else 0
                ans = max(ans, dp[i][j])
        return ans


```



##### 滑动窗口

我们注意到之所以两位置会比较多次，是因为重复子数组在两个数组中的位置可能不同。以 A = [3, 6, 1, 2, 4], B = [7, 1, 2, 9] 为例，它们的最长重复子数组是 [1, 2]，在 A 与 B 中的开始位置不同。

但如果我们知道了开始位置，我们就可以根据它们将 `A` 和 `B` 进行「对齐」，即：

```
A = [3, 6, 1, 2, 4]
B =    [7, 1, 2, 9]
           ↑  ↑
```

此时，最长重复子数组在 `A` 和 `B` 中的开始位置相同，我们就可以对这两个数组进行一次遍历，得到子数组的长度

我们可以枚举 A 和 B 所有的对齐方式。对齐的方式有两类：第一类为 A 不变，B 的首元素与 A 中的某个元素对齐；第二类为 B 不变，A 的首元素与 B 中的某个元素对齐。对于每一种对齐方式，我们计算它们相对位置相同的重复子数组即可。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/718_fig1.gif)

```python
class Solution:
    def findLength(self, A: List[int], B: List[int]) -> int:
        def maxLength(addA: int, addB: int, length: int) -> int:
            ret = k = 0
            for i in range(length):
                if A[addA + i] == B[addB + i]:
                    k += 1
                    ret = max(ret, k)
                else:
                    k = 0
            return ret
        
        n, m = len(A), len(B)
        ret = 0
        for i in range(n):
            length = min(m, n - i)
            ret = max(ret, maxLength(i, 0, length))
        for i in range(m):
            length = min(n, m - i)
            ret = max(ret, maxLength(0, i, length))
        return ret


```

