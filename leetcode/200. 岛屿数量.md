#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**提示：**

- m == grid.length
- n == grid[i].length
- 1 <= m, n <= 300
- `grid[i][j]` 的值为 '0' 或 '1'



#### 方法一：深度优先搜索

我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。

针对这道题，我们只需要对矩阵进行依次遍历，如果当前grid[x][y] == "1",则启动DFS模式。
找到与之相连的所有1，将其置为0。搜索结束后，我们找到了一个岛屿，岛屿数量+=1。
如此循环，最终返回岛屿数量即可



最终岛屿的数量就是我们进行深度优先搜索的次数。

下面的动画展示了整个算法。

![](https://pic.leetcode-cn.com/5dae0de2a06f4eae5113f9cadfa5c51bbcf0b9347c5861aa73c93d7bc1d50b34-image.png)

```
class Solution:
    def dfs(self, grid, i, j):
        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == "1":
            grid[i][j] = '0'
            self.dfs(grid, i - 1, j)
            self.dfs(grid, i + 1, j)
            self.dfs(grid, i, j - 1)
            self.dfs(grid, i, j + 1)
        return

    def numIslands(self, grid) -> int:

        count = 0
        rows = len(grid)
        cols = len(grid[0])

        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == "1":
                    self.dfs(grid, i, j)
                    count += 1

        return count

```

