# 前缀和

**目录**

- [引言](#引言)
- [什么是前缀和](#什么是前缀和)
- [参考链接](#参考链接)





#### 引言

​		今天来聊一道简单却十分巧妙的算法问题：算出一共有几个和为 `k` 的子数组。

​		给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

```
示例 1 :

输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

说明 :

- 数组的长度为 [1, 20,000]。
- 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1^e7, 1^e7]。



​		那我把所有子数组都穷举出来，算它们的和，看看谁的和等于 `k` 不就行了。

​		关键是，**如何快速得到某个子数组的和呢**，比如说给你一个数组 `nums`，让你实现一个接口 `sum(i, j)`，这个接口要返回 `nums[i..j]` 的和，而且会被多次调用，你怎么实现这个接口呢？

​		因为接口要被多次调用，显然不能每次都去遍历 `nums[i..j]`，有没有一种快速的方法在 O(1) 时间内算出 `nums[i..j]` 呢？这就需要**前缀和**技巧了。



#### 什么是前缀和

​		前缀和的思路是这样的，对于一个给定的数组 `nums`，我们额外开辟一个前缀和数组进行预处理：

```python
# 存储前缀和
pre_sum = [0]
tmp = 0
for num in nums:
	tmp += num
    pre_sum.append(tmp)
    
# pre_sum 的长度等于n+1，yu
```

​		这个前缀和数组 `preSum` 的含义也很好理解，`preSum[i]` 就是 `nums[0..i-1]` 的和。那么如果我们想求 `nums[i..j]` 的和，只需要一步操作 `preSum[j+1]-preSum[i]` 即可，而不需要重新去遍历数组了。

回到这个子数组问题，我们想求有多少个子数组的和为 k，借助前缀和技巧很容易写出一个解法：

```pthon
class Solution:
    def subarraySum(self, nums: list[int], k: int) -> int:
        ans = 0
        n = len(nums)

        # 存储前缀和
        pre_sum = [0]
        tmp = 0
        for num in nums:
            tmp += num
            pre_sum.append(tmp)

        for i in range(n):  # i:[0,n]
            for j in range(i, -1, -1):  # j[i,0]
                # 注意是i+1，因为pre_sum比nums多了一位
                if pre_sum[i + 1] - pre_sum[j] == k:
                    ans += 1
        return ans
```

这个解法的时间复杂度 `O(N^2)` 空间复杂度 `O(N)`，并不是最优的解法。不过通过这个解法理解了前缀和数组的工作原理之后，可以使用一些巧妙的办法把时间复杂度进一步降低。





#### 参考链接

- https://juejin.cn/post/6944913393627168798
- [https://zhuanlan.zhihu.com/p/107778275](https://zhuanlan.zhihu.com/p/107778275)