# 位图

##### 目录

- [定义](#定义)
- [原理](#原理)
- [例子](#例子)
- [位图处理大数据问题的场景](#位图处理大数据问题的场景)
- [BitMap的一些缺点](#BitMap的一些缺点)
- [参考链接](#参考链接)





#### 定义

BitMap算法的核心思想是用bit数组来记录0-1两种状态，然后再将具体数据映射到这个比特数组的具体位置，这个比特位设置成0表示数据不存在，设置成1表示数据存在。

BitMap算在在大量数据查询、去重等应用场景中使用的比较多，这个算法具有比较高的空间利用率。



#### 原理

​		BitMap 的基本原理就是用一个 bit 位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的。

1. 给定长度是10的bitmap，每一个bit位分别对应着从0到9的10个整型数。此时bitmap的所有位都是0。

   ![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/bitmap1.png)

2. 把整型数4存入bitmap，对应存储的位置就是下标为4的位置，将此bit置为1。

   ![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/bitmap2.png)

3. 把整型数2存入bitmap，对应存储的位置就是下标为2的位置，将此bit置为1。

   ![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/bitmap3.png)

要问此时bitmap里存储了哪些元素？就一目了然。

Bitmap不仅方便查询，还可以去除掉重复的整型数。





#### 例子

​		我们先来看个简单的问题。

​		假如给你20亿个**非负数**的int型整数，然后再给你一个非负数的int类型整数t，判断是否存在于这20亿数中，你会怎么做呢？

​		有人可能会用一个int数组，然后把20亿个数给存进去，然后再循环遍历一下就可以了。

​		想一下，这样的话，时间复杂度是O(n)，所需要的内存空间4byte * 20亿，一共需要80亿个字节，大概需要8GB的内存空间，显然有些计算机的内存一次是加载不了这么这么多的数据的。

**初步优化**

​		按照上面的做法，时间复杂度是O(n)，内存是8GB，实际上我们是可以把时间复杂度降低到O(1)的。

​		例如我们可以这样来存数据，把一个int非负整数n作为**数组下标**，如果n存在，则对应的值为1，如果不存在，对应的值为0。例如数组arr[n] = 1，表示n存在，arr[n] = 0表示n不存在。

​		那么，我们就可以把20亿个数作为下标来存，之后直接判断arr[t]的值，如果arr[t] = 1，则代表存在，如果arr[t] = 0，则代表不存在。这样，我们就可以把时间复杂度降低到O(1)。不过空间复杂度我们并没有降低。还稍微大了点。

> 由于int非负整数一共有 2^31 个，所以数组的大小需要 2^31 这么大。

​		这里可能有人说也可以用HashSet来存啊，时间复杂度也是近似O(1)。不过这里需要说明的是，HashSet里面存的必须是对象，也就是说需要把int包装成Integer，显然一个对象的话是更花销内存的，需要对象头啊什么的…..

##### 最终优化：bitmap

​		大家再想一个问题，虽然boolean是表示两种状态，但是boolean实际上占用了8bit啊，按道理8bit是可以表示128种状态的。而被我们拿来表示两个状态，是否也有点浪费了呢？

​		我们都知道，一个二进制位，有0和1两种状态，所以说，其实我们是可以用一个二进制位来代表一个int型的数是否存在的。例如对于1，3，5，7这四个数，如果存在的话，则可以这样表示：

![图片](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/640)

​		1代表这个数存在，0代表不存在。例如表中01010101代表1，3，5，7存在，0，2，4，6不存在。

​		那如果8，10，14也存在怎么存呢？如图，8，10，14我们可以存在第二个字节里

![图片](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/%E4%BD%8D%E5%9B%BE2.png)

​		以此类推。这样子，我们又可以把内存降低到之前的8分之一了。

​		这种采用一个二进制位来存储数据的方法，我们也叫做**bitmap算法**。





#### 位图处理大数据问题的场景

（1）给定40亿个不重复的 int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中。

解法：遍历40亿数字，映射到BitMap中，然后对于给出的数，直接判断指定的位上存在不存在即可。



（2）使用位图法判断整形数组是否存在重复

解法：遍历一遍，存在之后设置成1，每次放之前先判断是否存在，如果存在，就代表该元素重复。



（3）使用位图法进行元素不重复的整形数组排序

解法：遍历一遍，设置状态1，然后再次遍历，对状态等于1的进行输出，参考计数排序的原理。



（4）在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数

解法1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）。

解法2：采用两个BitMap，即第一个Bitmap存储的是整数是否出现，接着，在之后的遍历先判断第一个BitMap里面是否出现过，如果出现就设置第二个BitMap对应的位置也为1，最后遍历BitMap，仅仅在一个BitMap中出现过的元素，就是不重复的整数。

解法3：分治+Hash取模，拆分成多个小文件，然后一个个文件读取，直到内存装的下，然后采用Hash+Count的方式判断即可。

该类问题的变形问题，如已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。 8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。 （可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==12MBytes，这样，就用了小小的12M左右的内存表示了所有的8位数的电话）





#### BitMap的一些缺点

（1）数据碰撞。比如将字符串映射到 BitMap 的时候会有碰撞的问题，那就可以考虑用 Bloom Filter 来解决，Bloom Filter 使用多个 Hash 函数来减少冲突的概率。

（2）数据稀疏。又比如要存入(10,8887983,93452134)这三个数据，我们需要建立一个 99999999 长度的 BitMap ，但是实际上只存了3个数据，这时候就有很大的空间浪费，碰到这种问题的话，可以通过引入 Roaring BitMap 来解决。





#### 参考链接

- https://cloud.tencent.com/developer/article/1367334

- https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485235&idx=1&sn=37d2c0c956c167ecf428e70ba1a7408f&source=41#wechat_redirect

- https://www.cnblogs.com/54chensongxia/p/11591979.html#:~:text=BitMap%E7%AE%97%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3,%E9%AB%98%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%A9%E7%94%A8%E7%8E%87%E3%80%82