# 背包问题

**目录**

- [是什么](#是什么)
- [为什么](#为什么)
- [分类](#分类)
- [0-1背包问题](#0-1背包问题)
- [完全背包问题](#完全背包问题)
- [多重背包问题](#多重背包问题)
- [参考链接](#参考链接)



</br></br>

#### 是什么

​		背包问题是「动态规划」中十分经典的一类问题，背包问题本质上属于组合优化的「NP完全问题」。



</br></br>

#### 为什么

​		你可以将「 完全问题」简单理解为「无法直接求解」的问题。

​		例如「分解质因数」问题，我们无法像四则运算（加减乘除）那样，按照特定的逻辑进行求解。

​		只能通过「穷举」+「验证」的方式进行求解。

​		既然本质上是一个无法避免「穷举」的问题，自然会联想到「动态规划」，事实上背包问题也同时满足「无后效性」的要求。

​		这就是为什么「背包问题」会使用「动态规划」来求解的根本原因。



</br></br>

#### 分类

- 0-1背包问题
- 完全背包问题
- 多重背包问题

![](D:\git_code\Flee-as-a-bird-to-your-mountain\leetcode\动态规划\背包问题1.png)

至于背包九讲其他背包，面试几乎不会问，都是竞赛级别的了，leetcode上连多重背包的题目都没有，所以题库也告诉我们，0-1背包和完全背包就够用了。

而完全背包又是也是0-1背包稍作变化而来，即：完全背包的物品数量是无限的。

**所以背包问题的理论基础重中之重是0-1背包，一定要理解透！**

leetcode上没有纯0-1背包的问题，都是0-1背包应用方面的题目，也就是需要转化为01背包问题。

**所以我先通过纯0-1背包问题，把0-1背包原理讲清楚，后续再讲解leetcode题目的时候，重点就是讲解如何转化为0-1背包问题了**。

之前可能有些录友已经可以熟练写出背包了，但只要把这个文章仔细看完，相信你会意外收获！



</br></br>

#### 0-1背包问题

有 $N$ 件物品和一个容量是 $V$的 背包。每件物品有且只有一件。

第 $i$ 件物品的体积是 $v[i]$ ，价值是 $w[i]$。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

示例 1：

```
输入: N = 3, V = 4, v = [4,2,3], w = [4,2,3]
输出: 4
解释: 只选第一件物品，可使价值最大。
```

示例 2：

```
输入: N = 3, V = 5, v = [4,2,3], w = [4,2,3]
输出: 5
解释: 不选第一件物品，选择第二件和第三件物品，可使价值最大。
```

举个例子，方便说明原理：

物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

问背包能背的物品最大价值是多少？

> 以下讲解和图示中出现的数字都是以这个例子为例。

</br>

##### 确认状态转移方程

定义一个二维数组 $dp$ 存储最大价值，其中$ dp[i][j] $表示从下标为$[0-i]$的物品里任意取，放进容量为$j$的背包的最大价值。

只看这个二维数组的定义，一定会有点懵，看下面这个图：

![](D:\git_code\Flee-as-a-bird-to-your-mountain\leetcode\动态规划\背包问题-01背包1.png)

设第$ i $件物品体积为 $w$，价值为 $v$，根据第 $i$ 件物品是否添加到背包中，可以分两种情况讨论：

- 第 $i$ 件物品没添加到背包，总体积不超过 $j$ 的前$ i$ 件物品的最大价值就是总体积不超过 $j$ 的前$ i-1 $件物品的最大价值，$dp[i][j] = dp[i-1][j]$。
- 第$ i$ 件物品添加到背包中，$dp[i][j] = dp[i-1][j-w] + v$。

第$ i $件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：

$$
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)
$$

</br>

##### 初始化

**关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**。

首先从$dp[i][j]$的定义出发，如果背包容量 $j$ 为0的话，即$dp[i][0]$，无论是选取哪些物品，背包价值总和一定为0。如图：

![](D:\git_code\Flee-as-a-bird-to-your-mountain\leetcode\动态规划\背包问题-01背包2.png)



状态转移方程$dp[i][j] = dp[i-1][j-w] + v$，可以看出 $i $是由$ i-1 $推导出来，那么$i$为0的时候就一定要初始化。

$dp[0][j]$，即$i=0$，既是存放编号为0的时候，各个容量的背包所能存放的最大价值。

- 当$j < w[0]$时，$dp[0][j]$应该是$0$，因为背包容量比编号0的物品重量还小
- 当$j >= w[0]$时，$dp[0][j]$应该是$v[0]$，因为背包容量足够放编号0的物品

此时$dp$数组初始化情况如图所示：

![](D:\git_code\Flee-as-a-bird-to-your-mountain\leetcode\动态规划\背包问题-01背包3.png)



那么问题来了，**先遍历 物品还是先遍历背包重量呢？**

**其实都可以！！ 但是先遍历物品更好理解**。

```java
![背包问题-01背包4](D:\git_code\Flee-as-a-bird-to-your-mountain\leetcode\动态规划\背包问题-01背包4.png)// W 为背包总体积
// N 为物品数量
// weights 数组的大小 就是物品个数
// weights 数组存储 N 个物品的重量
// values 数组存储 N 个物品的价值
//定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值
int[] dp = new int[bagWeight + 1];

dp = [0] * (bag_weight + 1)

for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < w[i]) dp[i][j] = dp[i - 1][j]; 
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);

    }
}
```

**先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）**

例如这样：

```java
// weight数组的大小 就是物品个数
for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        if (j < w[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
    }
}
```

此时dp数组初始化情况如图所示：

$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])$，递归公式中可以看出$dp[i][j]$是靠$dp[i-1][j]$和$dp[i - 1][j - w[i]]$推导出来的。

$dp[i-1][j]$和$dp[i - 1][j - w[i]] $都在$dp[i][j]$的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：

![](D:\git_code\Flee-as-a-bird-to-your-mountain\leetcode\动态规划\背包问题-01背包4.png)

再来看看先遍历背包，再遍历物品呢，如图：

![](D:\git_code\Flee-as-a-bird-to-your-mountain\leetcode\动态规划\背包问题-01背包5.png)

**可以看出，虽然两个for循环遍历的次序不同，但是$dp[i][j]$所需要的数据就是左上角，根本不影响$dp[i][j]$公式的推导！**

但先遍历物品再遍历背包这个顺序更好理解。

**其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了**。



</br>

#### 空间优化

在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前$ i $件物品的状态仅与前$ i-1 $件物品的状态有关，因此可以将 $dp$ 定义为一维数组，其中 $dp[j] $既可以表示 $dp[i-1][j] $也可以表示 $dp[i][j]$。此时，
$$
dp[j] = max(dp[j], dp[j-w] + v)
$$
因为 $dp[j-w] $表示 $dp[i-1][j-w]$，因此不能先求 $dp[i][j-w]$，防止将 $dp[i-1][j-w] $覆盖。也就是说要先计算 $dp[i][j] $再计算 $dp[i][j-w]$，在程序实现时需要按倒序来循环求解。

```python
bag_weight = 4
weight = [1, 3, 4]
value = [15, 20, 30]
dp = [0] * (bag_weight + 1)
for i in range(len(weight)):  # 遍历物品
    for j in range(bag_weight, weight[i - 1], -1):  # 遍历背包
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
```



</br></br>

#### 完全背包问题

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

同样leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题，所以我这里还是以纯完全背包问题进行讲解理论和原理。

在下面的讲解中，我依然举这个例子：

背包最大重量为4。

物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

**每件商品都有无限个！**

问背包能背的物品最大价值是多少？

01背包和完全背包唯一不同就是体现在遍历顺序上

首先回顾下0-1背包问题的核心代码（状态转移方程）
$$
dp[j] = max(dp[j], dp[j-w] + v)
$$
**0-1背包****内嵌的循环**是**从大到小遍历**，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要**从小到大去遍历**，即：

```
for i in range(len(weight)):  # 遍历物品
    for j in range(weight[i], bag_weight + 1):  # 遍历背包
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
```

dp状态图如下：

![](D:\git_code\Flee-as-a-bird-to-your-mountain\leetcode\动态规划\背包问题-完全背包1.jpg)

**其实还有一个很重要的问题，为什么遍历物品在外层循环，遍历背包容量在内层循环？**

这个问题很多题解关于这里都是轻描淡写就略过了，大家都默认 遍历物品在外层，遍历背包容量在内层，好像本应该如此一样，那么为什么呢？

难道就不能遍历背包容量在外层，遍历物品在内层？

0-1背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。

**在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓！**

因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。

遍历物品在外层循环，遍历背包容量在内层循环，状态如图：

![](D:\git_code\Flee-as-a-bird-to-your-mountain\leetcode\动态规划\背包问题-完全背包2.jpg)

遍历背包容量在外层循环，遍历物品在内层循环，状态如图：

![](D:\git_code\Flee-as-a-bird-to-your-mountain\leetcode\动态规划\背包问题-完全背包-3.png)

看了这两个图，大家就会理解，完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值（这个值就是下标j之前所对应的dp[j]）。



</br></br>

#### 多重背包问题

对于多重背包，我在力扣上还没发现对应的题目，所以这里就做一下简单介绍，大家大概了解一下。

有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

多重背包和01背包是非常像的， 为什么和01背包像呢？

每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。

例如：

背包最大重量为10。

物品为：

|       | 重量 | 价值 | 数量 |
| ----- | ---- | ---- | ---- |
| 物品0 | 1    | 15   | 2    |
| 物品1 | 3    | 20   | 3    |
| 物品2 | 4    | 30   | 2    |

问背包能背的物品最大价值是多少？

和如下情况有区别么？

|       | 重量 | 价值 | 数量 |
| ----- | ---- | ---- | ---- |
| 物品0 | 1    | 15   | 1    |
| 物品0 | 1    | 15   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品2 | 4    | 30   | 1    |
| 物品2 | 4    | 30   | 1    |

毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。

这种方式来实现多重背包的代码如下：

```
def test_multi_pack1():
    '''版本一：改变物品数量为01背包格式'''
    weight = [1, 3, 4]
    value = [15, 20, 30]
    nums = [2, 3, 2]
    bag_weight = 10
    for i in range(len(nums)):
        # 将物品展开数量为1
        while nums[i] > 1:
            weight.append(weight[i])
            value.append(value[i])
            nums[i] -= 1
    
    dp = [0]*(bag_weight + 1)
    # 遍历物品
    for i in range(len(weight)):
        # 遍历背包
        for j in range(bag_weight, weight[i] - 1, -1):
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
    
    print(" ".join(map(str, dp)))

def test_multi_pack2():
    '''版本：改变遍历个数'''
    weight = [1, 3, 4]
    value = [15, 20, 30]
    nums = [2, 3, 2]
    bag_weight = 10

    dp = [0]*(bag_weight + 1)
    for i in range(len(weight)):
        for j in range(bag_weight, weight[i] - 1, -1):
            # 以上是01背包，加上遍历个数
            for k in range(1, nums[i] + 1):
                if j - k*weight[i] >= 0:
                    dp[j] = max(dp[j], dp[j - k*weight[i]] + k*value[i])

    print(" ".join(map(str, dp)))


if __name__ == '__main__':
    test_multi_pack1()
    test_multi_pack2()
```

从代码里可以看出是01背包里面在加一个for循环遍历一个每种商品的数量。 和01背包还是如出一辙的。



</br></br>

#### 参考链接

- https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.md
- https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.md
- https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.md