# 09.环形链表II

**目录**

- [leetcode题](#leetcode题)





### leetcode题

#### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。



 

**示例 1：**

![img](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

 

**提示：**

- 链表中节点的数目范围在范围 `[0, 104]` 内
- `-10^5 <= Node.val <= 10^5`
- `pos` 的值为 `-1` 或者链表中的一个有效索引

 

**进阶：**你是否可以使用 `O(1)` 空间解决此题？





## 思路

> 双指针，可以看下[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

- 这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第K个节点、寻找环入口、寻找公共尾部入口等。

##### 算法流程：

1. **双指针第一次相遇：** 设两指针 `fast`，`slow` 指向链表头部 `head`，`fast` 每轮走 $2$ 步，`slow` 每轮走 $1$ 步；
   1. **第一种结果：** `fast` 指针走过链表末端，说明链表无环，直接返回 `null`；
   2. **第二种结果：** 当`fast == slow`时， 两指针在环中 **第一次相遇** 。下面分析此时`fast` 与 `slow`走过的 **步数关系** ：
      1. 设链表共有 $a+b$ 个节点，其中 链表头部到链表入口 有 $a $个节点（不计链表入口节点）， 链表环 有 $b$ 个节点（这里需要注意，$a$ 和 $b$ 是未知数，例如图解上链表 $a=4$ , $b=5$）；设两指针分别走了 $f$，$s$ 步，则有：
         1. `fast` 走的步数是`slow`步数的 `2` 倍，即` f = 2s`；（解析：` fast` 每轮走` 2` 步）
         2. `fast `比 `slow`多走了 `n` 个环的长度，即 `f = s + nb`；（ 解析： 双指针都走过 `a` 步，然后在环内绕圈直到重合，重合时 `fast` 比 `slow` 多走 **环的长度整数倍** ）；
         3. 以上两式相减得：`f = 2nb`，`s = nb`，即`fast`和`slow `指针分别走了 `2n`，`n` 个 环的周长 （注意： `n` 是未知数，不同链表的情况不同）。
2. 目前情况分析：

   - 如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时的步数 是：`k=a+nb`（先走 `a` 步到入口节点，之后每绕 `1` 圈环（ `b` 步）都会再次到入口节点）。

   - 而目前，`slow` 指针走过的步数为 `nb` 步。因此，我们只要想办法让 `slow` 再走 `a` 步停下来，就可以到环的入口。
   - 但是我们不知道` a` 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 `a` 步后，两者在入口节点重合。那么从哪里走到入口节点需要 `a` 步？答案是链表头部`head`。
3. **双指针第二次相遇**：
   - `slow`指针 位置不变 ，将`fast`指针重新 指向链表头部节点 ；`slow`和`fast`同时每轮向前走 `1` 步；
   - 当 `fast` 指针走到`f = a` 步时，`slow `指针走到步`s = a+nb`，此时 两指针重合，并同时指向链表环入口 。
4. **返回`slow`指针指向的节点。**

![](https://pic.leetcode-cn.com/a4788076d4f3ad247c2023f92bb1585d05c5132ece7ed1205e2e171e25648adc-Picture1.png)

![](https://pic.leetcode-cn.com/4ccc10d8af901acf43f4db0e5cd0e3c537aeb2346f57ad66c92cb9cbba0f1f73-Picture2.png)

![](https://pic.leetcode-cn.com/5bfd893f81962daed27dd9fc3c96e426b168f4e940e5ab7541c323ee416548ec-Picture3.png)

![](https://pic.leetcode-cn.com/387bfbbe71b3f1d462f72472b8168b894b7c41907e8a66bb770cd7a7ad04d48d-Picture4.png)

![](https://pic.leetcode-cn.com/54d3a446f6acf92de2e51e639fb4f05abffa468334a778bd74c63f990cd73276-Picture5.png)

![](https://pic.leetcode-cn.com/9a319387f7fe8d3c3acb9d6bc0bc9f7471ccff6699115db724a99d2acb7b68ca-Picture6.png)

![](https://pic.leetcode-cn.com/f3977a8e28b45952e01334c1c86d70e3e822c913f81318108052aea81e365788-Picture7.png)

![](https://pic.leetcode-cn.com/114969493875dcdca1d1bea8fb997643975d25b4ddb185dd071a185ed435cccd-Picture8.png)

![](https://pic.leetcode-cn.com/c7ab2f7023d5f8c7fcae71280b56c1ec6acf65f634ef82d61713fcff1ea2ee75-Picture9.png)

![](https://pic.leetcode-cn.com/af490a825982d42be6baf7e87a3e1cf181420bb9f46aa0ccbb190719c8b4dd92-Picture10.png)

![](https://pic.leetcode-cn.com/f31767986757b751bfec07f824714044611b4a54bf8e794b2f4684a175dde044-Picture11.png)



```python
class Solution:
    def detectCycle(self, head) -> bool:
        fast, slow = head, head
        while True:
            if not (fast and fast.next):
                return

            fast, slow = fast.next.next, slow.next
            if fast == slow:
                break

        fast = head
        while fast != slow:
            fast, slow = fast.next, slow.next

        return fast

```

