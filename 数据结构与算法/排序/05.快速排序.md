# 快速排序

#### 目录

- [是什么](#是什么)
- [原理](#原理)
- [运行过程](#运行过程)
- [代码实现](#代码实现)
- [时间复杂度](#时间复杂度)



#### 是什么

​		快速排序（Quick Sort），又称划分交换排序（partition-exchange sort）



#### 原理

​		快速排序的基本思想就是：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。



#### 运行过程

快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。

> ① 从数列中挑出一个元素，称为 “基准”（pivot），
> ② 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
> ③ 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

 递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

![](https://picx.zhimg.com/v2-d4e5d0a778dba725091d8317e6bac939_720w.webp?source=d16d100b)

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F1.png)





#### 快速排序法为什么一定要从右边开始的原因

```
while low < high:
	while low < high and a[high] >= mid:
		high -= 1

	while low < high and a[low] <= mid:
		low += 1

	if low < high:
    	a[low], a[high] = a[high], a[low]
```

这里两个while的顺序是不能改变的，想一想：

假设对如下进行排序：

  ![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F2.png)

如上图，6在左，9在右  我们将6作为基数。

假设从左边开始（与正确程序正好相反）

于是low 就会移动到现在的 数字 7 那个位置停下来，而  high  原来在 数字 9 那个位置 ，因为

```
while low < high and a[high] >= mid:
while low < high and a[low] <= mid:
```

于是，low 也会停留在数字7 那个位置，于是问题来了。当你最后交换基数6与7时，不对呀！！。

问题在于当我们先从在边开始时，那么 low 所停留的那个位置肯定是大于基数6的，而在上述例子中，为了满足 i

但最后交换回去的时候，7就到了左边，不行，因为我们原本 交换后数字6在边应该是全部小于6，右边全部大于6.但现在不行了。

于是，我们必须从右边开始，也就是从基数的对面开始。





#### 代码实现

```python
def quick_sort(a, start, end):
    if start < end:
        mid = a[start]
        high = end
        low = start
        while low < high:
            while low < high and a[high] >= mid:
                high -= 1

            while low < high and a[low] <= mid:
                low += 1

            if low < high:
                a[low], a[high] = a[high], a[low]

        a[start], a[low] = a[low], a[start]
        quick_sort(a, start, low - 1)
        quick_sort(a, low + 1, end)
        
    return


if __name__ == '__main__':
    a = [1, 5, 2, 4, 6, 2, 4, 5, 2, 1, 3]
    quick_sort(a, 0, len(a) - 1)
    print(a)
```



#### 时间复杂度

- 最优时间复杂度O(nlogn)
- 最坏时间复杂度O(n^2)
