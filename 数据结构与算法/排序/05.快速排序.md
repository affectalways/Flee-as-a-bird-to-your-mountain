# 快速排序

#### 目录

- [是什么](#是什么)
- [原理](#原理)
- [运行过程](#运行过程)



#### 是什么

​		快速排序（Quick Sort），又称划分交换排序（partition-exchange sort）



#### 原理

​		冒泡排序的基本思想就是：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。



#### 运行过程

快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。

> ① 从数列中挑出一个元素，称为 “基准”（pivot），
> ② 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
> ③ 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

 递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

![](https://picx.zhimg.com/v2-d4e5d0a778dba725091d8317e6bac939_720w.webp?source=d16d100b)

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F1.png)

```python
def quick_sort(a, start, end):
    if start < end:
        mid = a[start]
        high = end
        low = start
        while low < high:
            while low < high and a[high] >= mid:
                high -= 1

            while low < high and a[low] <= mid:
                low += 1

            if low < high:
                a[low], a[high] = a[high], a[low]

        a[start], a[low] = a[low], a[start]
        quick_sort(a, start, low - 1)
        quick_sort(a, low + 1, end)
        
    return


if __name__ == '__main__':
    a = [1, 5, 2, 4, 6, 2, 4, 5, 2, 1, 3]
    quick_sort(a, 0, len(a) - 1)
    print(a)
```



#### 时间复杂度

- 最优时间复杂度O(nlogn)
- 最坏时间复杂度O(n^2)
