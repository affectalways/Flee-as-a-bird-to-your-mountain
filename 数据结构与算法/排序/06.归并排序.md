# 归并排序

#### 目录

- [是什么](#是什么)
- [原理](#原理)
- [运行过程](#运行过程)
- [代码实现](#代码实现)
- [时间复杂度](#时间复杂度)



#### 是什么

​		归并排序（MERGE-SORT）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题**分**(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。



#### 运行过程

- ##### 分而治之

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F1.png)

可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。**分**阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。



- ##### 合并相邻有序子序列

再来看看**治**阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2.png)

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F3.png)





#### 代码实现

```python
def merge_sort():
    '''
        归并排序: 分，治
    :return:
    '''
    a = [1, 4, 52, 6, 8, 2, 44, 33, 6, 1, 4, 0]
    print(divide(a))


def divide(tmp_list):
    '''
        分
    :param tmp_list:
    :return:
    '''
    # 直到分到1，返回
    if len(tmp_list) <= 1:
        return tmp_list
    divide_index = len(tmp_list) // 2
    left = tmp_list[:divide_index]
    right = tmp_list[divide_index:]
    # 递归分
    left = divide(left)
    right = divide(right)
    # 调用方法：zhi
    return rule(left, right)


def rule(left, right):
    '''
        治
    :param left:
    :param right:
    :return:
    '''
    result = []
    left_start = 0
    right_start = 0

    while left_start < len(left) and right_start < len(right):
        if left[left_start] <= right[right_start]:
            result.append(left[left_start])
            left_start += 1
        else:
            result.append(right[right_start])
            right_start += 1
    # 将剩余的元素添加到result中
    if left_start < len(left):
        result.extend(left[left_start:])
    if right_start < len(right):
        result.extend(right[right_start:])

    return result
```



#### 时间复杂度

- 最优时间复杂度O(nlogn)
- 最坏时间复杂度O(nlogn)