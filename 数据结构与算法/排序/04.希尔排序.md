# 希尔排序

#### 目录

- [是什么](#是什么)
- [原理](#原理)
- [运行过程](#运行过程)
- [时间复杂度](#时间复杂度)



#### 是什么

​		希尔排序（IDonald Shell Sort）是插入排序的一种，一个更高效的版本，也称为缩小增量排序，**同时该算法是冲破O(n2）的第一批算法之一。



#### 原理

​		**希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。**

​		简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。

​		而希尔排序在数组中采用跳跃式分组的策略，通过某个**增量**将数组元素划分为若干组，然后分组进行插入排序，随后**逐步缩小增量**，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。

　　我们来看下希尔排序的基本步骤，在此我们选择**增量gap=length/2**，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为**增量序列**。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。

  ![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png)



```python
def shell_sort(unsort_data):
    data_len = len(unsort_data)
    gap = data_len // 2

    while gap > 0:
        for i in range(gap, data_len):
            for j in range(i, 0, -gap):
              
                    if unsort_data[j] < unsort_data[j - gap]:
                        unsort_data[j], unsort_data[j - gap] = unsort_data[j - gap], unsort_data[j]
        gap = gap // 2

    return unsort_data
```





#### 时间复杂度

- 最优时间复杂度：根据步长序列的不同而不同
- 最坏时间复杂度O(n^2)