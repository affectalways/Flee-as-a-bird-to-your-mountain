# 选择排序

#### 目录

- [是什么](#是什么)
- [原理](#原理)
- [运行过程](#运行过程)
- [时间复杂度](#时间复杂度)



#### 是什么

​		选择排序(Selection sort)是一种简单直观的排序算法。



#### 原理

​		选择排序(Selection sort)的基本思想就是：

- 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；
- 接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。
- 以此类推，直到所有元素均排序完毕。



#### 运行过程

以数列{20,40,30,10,60,50}为例，演示其选择排序过程(如下图)。

![img](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/v2-c7bbbfaf4e9853595f439e25420197a8_1440w.jpg)

排序流程如下：

1. i=0。找出a[1...5]中的最小值a[3]=10，然后将a[0]和a[3]互换。 数组变化：20,40,30,10,60,50 -- > 10,40,30,20,60,50
2. i=1。找出a[2...5]中的最小值a[3]=20，然后将a[1]和a[3]互换。 数组变化：10,40,30,20,60,50 -- > 10,20,30,40,60,50*
3. i=2。找出a[3...5]中的最小值，由于该最小值大于a[2]，该趟不做任何处理。
4. i=3。找出a[4...5]中的最小值，由于该最小值大于a[3]，该趟不做任何处理。
5. i=4。交换a[4]和a[5]的数据。 数组变化：10,20,30,40,60,50 -- > 10,20,30,40,50,60

```python
def select_sort(array):
    length = len(array)
    for i in range(length):
        # 记录最小位置
        min_index = i
        # 从i+1位置到末尾选出最小数据
        for j in range(i + 1, length):
            if array[j] < array[min_index]:
                min_index = j

            # 如果选择出的数据不在正确位置，进行交换
            if min_index != i:
                array[min_index], array[i] = \
                    array[i], array[min_index]

    return array

```





#### 时间复杂度

- 最优时间复杂度O(n^2)
- 最坏时间复杂度O(n^2)