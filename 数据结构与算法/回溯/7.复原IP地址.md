# 7.复原IP地址

##### 目录

- [leetcode题](#leetcode题)



### leetcode题

#### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

- 例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是"0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。

给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

 

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

**示例 2：**

```
输入：s = "0000"
输出：["0.0.0.0"]
```

**示例 3：**

```
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

**提示：**

- 1 <= s.length <= 20
- s 仅由数字组成



## 思路

```
回溯
```

切割问题可以抽象为树型结构，如图：

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/91.png)

```python
class Solution:
    def restoreIpAddresses(self, s: str):
        ans = []
        length = len(s)
        if not length:
            return ans

        def is_valid(t: str):
            # 若数字是0开头，不合法；数字0是被允许的，所以len(t) > 1
            if t.startswith('0') and len(t) > 1:
                return False

            # 若数字不在0和255范围内，不合法
            if not 0 <= int(t) <= 255:
                return False

            return True

        def back(path, start):
            # 注意：限制path长度为4并且start==length，缺一不可
            if len(path) == 4 and start == length:
                ans.append('.'.join(path[:]))
                return

            for i in range(start, length):
                if not is_valid(s[start: i + 1]):
                    # 若当前被截取的子串大于255或者大于三位数，直接结束本层循环
                    break

                path.append(s[start: i + 1])
                back(path, i + 1)
                path.pop()

        back([], 0)

        return ans
```

