# 02.二分查找

### 目录

- [什么是二分查找](#什么是二分查找)
- [二分查找使用场景](#二分查找使用场景)
- [零、二分查找框架](#零、二分查找框架)
- [案例](#案例)
  - [寻找一个数（基本的二分搜索）](#寻找一个数（基本的二分搜索）)
  - [寻找左侧边界的二分搜索](#寻找左侧边界的二分搜索)
  - [寻找右侧边界的二分查找](#寻找右侧边界的二分查找)


</br></br>

> 先给大家讲个笑话乐呵一下：
>
> 有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。
>
> 从此，图书馆丢了 N - 1 本书。

</br></br>

### 什么是二分查找

​		二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为**有序表**，但插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。

​		首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字 ，则进一步查找前一子表，否则进一 步查找后一子表。

​		重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE1.png)



</br></br>

### 二分查找使用场景

- 在一个序列中查找某一个元素是否存在。
- 二分查找只能作用于**有序的列表**。



</br></br>

> 本文就来探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。而且，我们就是要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。

### 零、二分查找框架

```python
def binary_search(nums, target):
    length = len(nums)
    left, right = 0, length - 1
    while left <= right:
        mid = left + (right - left) / 2
        if nums[mid] == target:
            ...
        elif nums[mid] < target:
            left = ...
        elif nums[mid] > target:
            right = ...

    return ...
```

**分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节**。

其中 `...` 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。

另外声明一下，计算 mid 时需要防止溢出，代码中 `left + (right - left) / 2` 就和 `(left + right) / 2` 的结果相同，但是有效防止了 `left` 和 `right` 太大直接相加导致溢出。



</br></br>

### 案例

#### 寻找一个数（基本的二分搜索）

这个场景是最简单的，可能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。

```
def binary_search(nums, target):
    length = len(nums)
    left, right = 0, length - 1  # 注意: right = length - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1  # 注意直接+1了
        elif nums[mid] > target:
            right = mid - 1  # 注意直接-1了

    return -1
```

**Q&A**

##### 1.为什么 while 循环的条件中是 <=，而不是 <？

答：因为初始化 `right` 的赋值是 `nums.length - 1`，即最后一个元素的索引，而不是 `nums.length`。

这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 `[left, right]`，后者相当于左闭右开区间 `[left, right)`，因为索引大小为 `nums.length` 是越界的。

我们这个算法中使用的是前者 `[left, right]` 两端都闭的区间。**这个区间其实就是每次进行搜索的区间**。

什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：

```
    if(nums[mid] == target)
        return mid; 
```

但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？**搜索区间为空的时候应该终止**，意味着你没得找了，就等于没找到嘛。

`while(left <= right)` 的终止条件是 `left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见**这时候区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

`while(left < right)` 的终止条件是 `left == right`，写成区间的形式就是 `[right, right]`，或者带个具体的数字进去 `[2, 2]`，**这时候区间非空**，还有一个数 2，但此时 while 循环终止了。也就是说这区间 `[2, 2]` 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

</br>

##### 2.为什么 `left = mid + 1`，`right = mid - 1`？我看有的代码是 `right = mid` 或者 `left = mid`，没有这些加加减减，到底怎么回事，怎么判断？

答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。

刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 `[left, right]`。那么当我们发现索引 `mid` 不是要找的 `target` 时，下一步应该去搜索哪里呢？

当然是去搜索 `[left, mid-1]` 或者 `[mid+1, right]` 对不对？**因为 `mid` 已经搜索过，应该从搜索区间中去除**。

</br>

##### 3.此算法有什么缺陷？

答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。

比如说给你有序数组 `nums = [1,2,2,2,3]`，`target` 为 2，此算法返回的索引是 2，没错。但是如果我想得到 `target` 的左侧边界，即索引 1，或者我想得到 `target` 的右侧边界，即索引 3，这样的话此算法是无法处理的。

这样的需求很常见，**你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找时间复杂度了**。

我们后续的算法就来讨论这两种二分查找的算法。



</br></br>

#### 寻找左侧边界的二分搜索

以下是最常见的代码形式，其中的标记是需要注意的细节：

```python
def left_bound(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            # 锁定左侧边界
            right = mid - 1
        elif nums[mid] < target:
            left = mid + 1
        elif nums[mid] > target:
            right = mid - 1
            
    # 检查left越界情况
    if left >= len(nums) or nums[left] != target:
        return -1
        
    return left
```

</br>

##### 1.**为什么该算法能够搜索左侧边界**？

答：关键在于对于 `nums[mid] == target` 这种情况的处理：

```
if nums[mid] == target:
	rigth = mid
```

可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 `right`，在区间 `[left, mid]` 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。

</br>

##### 2.为什么返回 `left` 而不是 `right`？

答：都是一样的，因为 while 终止的条件是 `left == right`。



</br></br>

#### 寻找右侧边界的二分查找

类似寻找左侧边界的算法，这里也会提供两种写法，还是常见的左闭右闭的写法

```python
def binary_search(nums, target):
    length = len(nums)
    left, right = 0, length - 1  # 注意: right = length - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            left = mid + 1
        elif nums[mid] < target:
            left = mid + 1  # 注意直接+1了
        elif nums[mid] > target:
            right = mid - 1  # 注意直接-1了
            
    if right < 0 or nums[right] != target:
        return -1
    
    return right
```

</br>

##### 1.为什么这个算法能够找到右侧边界？

答：类似地，关键点还是这里：

```
if (nums[mid] == target) {
    left = mid + 1;
    }
```

当 `nums[mid] == target` 时，不要立即返回，而是增大「搜索区间」的下界 `left`，使得区间不断向右收缩，达到锁定右侧边界的目的。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE3.png)

