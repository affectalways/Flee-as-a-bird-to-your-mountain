# 10.HTTP1.0、1.1、2.0的主要区别

### 目录

- [先说结论](#先说结论)
- [HTTP1.0](#HTTP1.0)
- [HTTP1.1](#HTTP1.1)
- [HTTP2.0](#HTTP2.0)



</br></br>

#### **先说结论**

结论1：从HTTP/1.0到HTTP/2，都是利用TCP作为底层协议进行通信的。

结论2：HTTP/1.1，引进了长连接(keep-alive)，减少了建立和关闭连接的消耗和延迟。

结论3：HTTP/2，引入了多路复用：连接共享，提高了连接的利用率，降低延迟。



</br></br>

## HTTP1.0

HTTP 1.0是一种无状态、无连接的应用层协议。

#### 特性

- 无状态：服务器不跟踪、不记录请求相关内容
- 无连接：每次请求都需要进行一次TCP连接

</br>

#### 特性详解

1. **无状态**
   - 对于无状态的特性可以借助cookie/session机制来做身份认证和状态记录
2. **无连接**
   - 每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。
   - 队头阻塞：HTTP 1.0规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的



</br></br>

## HTTP1.1

HTTP 1.1继承了HTTP 1.0的简单，克服了HTTP 1.0性能上的问题。

#### 特性

- 长连接：
  - 新增Connection字段，可以设置keep-alive值保持连接不断开
  - HTTP 1.1默认保持长连接，数据传输完成保持tcp连接不断开

- 管道化(**pipelining**)：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回
- 缓存处理：新增字段cache-control
- 断点传输

</br>

#### 特性详解

1. **管道化**

   > - 基于长连接的基础，我们先看没有管道化请求响应：
   >
   >   tcp没有断开，用的同一个通道
   >
   >   ```
   >   请求1 > 响应1 --> 请求2 > 响应2 --> 请求3 > 响应3
   >   ```
   >
   >   管道化的请求响应：
   >
   >   ```
   >   请求1 --> 请求2 --> 请求3 > 响应1 --> 响应2 --> 响应3
   >   ```
   >
   >   即使服务器先准备好响应2,也是按照请求顺序先返回响应1
   >
   >   虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题

2. **缓存处理**

   > 当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求
   >
   > 通过设置字段cache-control来控制

3. 断点传输

   > 在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率
   >
   > 在 Header 里两个参数实现的，客户端发请求时对应的是 Range 服务器端响应时对应的是 Content-Range



</br></br>

## HTTP2.0

#### 特性

- 二进制分帧
- 多路复用
- header压缩（头部压缩）
- 服务器推送

</br>

#### 特性详解

- **二进制分帧**

  - HTTP 1.x的解析是基于文本。基于文本协议的格式解析存在缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP 2.0的协议解析决定采用二进制格式，实现方便且健壮
  - HTTP 2.0通过在应用层和传输层之间增加一个二进制分层帧，突破了HTTP 1.1的性能限制，改进传输性能。

- **多路复用**： **多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。**

  > - **流（stream）**：已建立连接上的双向字节流。
  > - **消息**：与逻辑消息对应的完整的一系列数据帧。
  > - **帧（frame）**：HTTP 2.0通信的最小单位，每个帧包含头部，至少也会标识出当前所属的流（stream_id）

- **header压缩**：HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

- **服务器推送**：服务器可以额外的向客户端推送资源，而无需客户端明确的请求

