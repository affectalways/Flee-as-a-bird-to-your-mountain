# 11.HTTP2.0

### 目录

- [HTTP/1.x 缺陷](HTTP/1.x 缺陷)
- [多路复用](#多路复用)
- [二进制分帧层](#二进制分帧层)
- [服务端推送](#服务端推送)
- [首部压缩](#首部压缩)
- [参考链接](#参考链接)





</br></br>

### HTTP/1.x 缺陷

HTTP/1.x 实现简单是以牺牲性能为代价的：

- 客户端需要使用多个连接才能实现并发和缩短延迟；
- 不会压缩请求和响应首部，从而导致不必要的网络流量；
- 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。



</br></br>

### 多路复用

**多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。**

 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的**请求-响应**消息。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/HTTP2.0多路复用1.png)

因为HTTP2.0可以很容易的实现多流并行而不用依赖建立多个TCP连接，HTTP2.0把HTTP协议通信的基本单位缩小为一个一个的帧，这些帧对应逻辑流中的消息，并行的在同一个TCP连接上交换信息。

> - **流（stream）**：已建立连接上的双向字节流。
> - **消息**：与逻辑消息对应的完整的一系列数据帧。
> - **帧（frame）**：HTTP 2.0通信的最小单位，每个帧包含头部，至少也会标识出当前所属的流（stream_id）



</br></br>

### 二进制分帧层

- HTTP 1.x的解析是基于文本。基于文本协议的格式解析存在缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP 2.0的协议解析决定采用二进制格式，实现方便且健壮
- HTTP 2.0通过在应用层和传输层之间增加一个二进制分层帧，突破了HTTP 1.1的性能限制，改进传输性能。

在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段….. 的情况下, HTTP/2 是如何做到「突破 HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量」的 ?

关键之一就是在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个[二进制分帧层](https://www.zhihu.com/search?q=二进制分帧层&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A75364178})。

HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/HTTP2.0多路复用2.png)



在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。

- 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。

- 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。

- 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

  ![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/HTTP2.0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A85.png)



在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。

HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的[双向数据流](https://www.zhihu.com/search?q=双向数据流&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A75364178})。

在过去， HTTP 性能优化的**关键并不在于高带宽**，而是**低延迟**。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。

HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

总结：

- **单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大**
- **由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快**





</br></br>

### 服务端推送

HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/HTTP2.0多路复用3.png)





</br></br>

### 首部压缩

HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。

HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。

不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/HTTP2.0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A86.png)



</br></br>

### 参考链接

- https://www.zhihu.com/question/34074946
