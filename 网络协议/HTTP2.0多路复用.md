# HTTP2.0多路复用

### 目录

- [流的概念](#流的概念)
- [多路复用](#多路复用)



</br></br>

在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：

- 第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）
- 第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。

HTTP/2的多路复用就是为了解决上述的两个性能问题。 在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

要了解多路复用，首先要了解下流。

</br>

### 流的概念

流（Stream），服务器和客户端在HTTP 2.0连接内用于交换帧数据的独立双向序列，逻辑上可看做一个较为完整的交互处理单元，即表达一次完整的资源请求-响应数据交换流程；一个业务处理单元，在一个流内进行处理完毕，这个流生命周期完结。

特点如下：

- 一个HTTP/2连接可同时保持多个打开的流，任一端点交换帧
- 流可被客户端或服务器单独或共享创建和使用
- 流可被任一端关闭
- 在流内发送和接收数据都要按照顺序
- 流的标识符自然数表示，1~2^31-1区间，有创建流的终端分配
- 流与流之间逻辑上是并行、独立存在

> **流的概念提出，就是为了实现多路复用。**



</br></br>

### 多路复用

多路复用允许同时通过**单个HTTP 2.0连接发起多重的请求-响应**（右侧图片）。

![](D:\git_code\Flee-as-a-bird-to-your-mountain\网络协议\pictures\HTTP2.0\多路复用.png)



**多路复用再结合流**

逻辑图如下：

![](D:\git_code\Flee-as-a-bird-to-your-mountain\网络协议\pictures\HTTP2.0\多路复用1.png)

实际传输可能是这样的：

![](D:\git_code\Flee-as-a-bird-to-your-mountain\网络协议\pictures\HTTP2.0\多路复用2.png)

就是说在一个TCP连接上，我们可以向对方不断发送一个个的消息，这里每一个消息看成是一帧，而每一帧有个`stream identifier` 的字段标明这一帧属于哪个 `流`，然后在对方接收时，根据 `stream identifier` 拼接每个 `流` 的所有帧组成一整块数据。我们把 HTTP/1.x 每个请求都当作一个 `流`，那么请求化成多个流，请求响应数据切成多个帧，不同流中的帧交错地发送给对方，这就是HTTP/2中的 `多路复用`。

> 流-》多个消息（帧）

需要抽象化一些，就好理解了：

1. 每一个帧可看做是一个学生，流可以认为是组（流标识符为帧的属性值），一个班级（一个连接）内学生被分为若干个小组，每一个小组分配不同的具体任务。
2. HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个小组任务都需要建立一个班级，多个小组任务多个班级，1:1比例
3. HTTP/1.1 Pipeling解决方式为，若干个小组任务排队串行化单线程处理，后面小组任务等待前面小组任务完成才能获得执行机会，一旦有任务处理超时等，后续任务只能被阻塞，毫无办法，也就是人们常说的线头阻塞
4. HTTP/2多个小组任务可同时并行（严格意义上是并发）在班级内执行。一旦某个小组任务耗时严重，但不会影响到其它小组任务正常执行
5. 针对一个班级资源维护要比多个班级资源维护经济多了，这也是多路复用出现的原因

这样简单梳理，就有些小清晰了。

