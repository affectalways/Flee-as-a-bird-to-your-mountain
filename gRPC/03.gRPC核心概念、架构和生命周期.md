# 03.gRPC核心概念、架构和生命周期

### 目录

- [gRPC调用模型](#gRPC调用模型)
- [gRPC调用方式](#gRPC调用方式)
- [使用API](#使用API)
- [使用protocol_buffers](#使用protocol_buffers)
- [protocol_buffers版本](#protocol_buffers版本)
- [参考链接](#参考链接)



</br></br>

### gRPC调用模型

![](D:\git_code\Flee-as-a-bird-to-your-mountain\gRPC\pictures\grpc1.svg)

1. 客户端（gRPC Stub）调用 A 方法，发起 RPC 调用。
2. 对请求信息使用 Protobuf 进行对象序列化压缩（IDL）。
3. 服务端（gRPC Server）接收到请求后，解码请求体，进行业务逻辑处理并返回。
4. 对响应结果使用 Protobuf 进行对象序列化压缩（IDL）。
5. 客户端接受到服务端响应，解码请求体。回调被调用的 A 方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果。



</br></br>

### gRPC调用方式

在gRPC中你可以定义四种类型的服务方法：

- ##### Unary RPC（普通RPC）

- ##### Client streaming RPC（客户端流式RPC）

- ##### Server streaming RPC（服务端流式RPC）

- ##### Bidirectional streaming RPC（双向流式RPC）

</br>

#### Unary RPC（普通RPC）

> Unary RPC：客户端发送单个请求并接收单个响应。

客户端向服务器发送一个请求，然后得到一个响应，就像普通的函数调用一样。

```
rpc SayHello(HelloRequest) returns (HelloResponse);
```

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/gRPC%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F01.png)



##### Server端

```go
type SearchService struct{}

func (s *SearchService) Search(ctx context.Context, r *pb.SearchRequest) (*pb.SearchResponse, error) {
    return &pb.SearchResponse{Response: r.GetRequest() + " Server"}, nil
}

const PORT = "9001"

func main() {
    server := grpc.NewServer()
    pb.RegisterSearchServiceServer(server, &SearchService{})

    lis, err := net.Listen("tcp", ":"+PORT)
    ...

    server.Serve(lis)
}
```

- 创建 gRPC Server 对象，你可以理解为它是 Server 端的抽象对象。
- 将 SearchService（其包含需要被调用的服务端接口）注册到 gRPC Server。的内部注册中心。这样可以在接受到请求时，通过内部的 “服务发现”，发现该服务端接口并转接进行逻辑处理。
- 创建 Listen，监听 TCP 端口。
- gRPC Server 开始 lis.Accept，直到 Stop 或 GracefulStop。

- 服务器流式 rpc，其中客户端向服务器发送请求，并获得一个流来读取一系列消息。客户端从返回的流中读取，直到没有更多的消息。gRPC 保证在单个 RPC 调用中的消息是有序的。

##### Client端

```go
func main() {
    conn, err := grpc.Dial(":"+PORT, grpc.WithInsecure())
    ...
    defer conn.Close()

    client := pb.NewSearchServiceClient(conn)
    resp, err := client.Search(context.Background(), &pb.SearchRequest{
        Request: "gRPC",
    })
    ...
}

```

- 
- 创建 SearchService 的客户端对象。
- 发送 RPC 请求，等待同步响应，得到回调后返回响应结果。

</br>

#### Client streaming RPC（客户端流式RPC）

> Client streaming RPC：客户端发送消息流，服务器以单个消息响应。

其中客户端写入一系列消息并将其发送到服务器，同样使用提供的流。一旦客户端完成了消息的写入，它就等待服务器读取消息并返回响应。同样，gRPC 保证在单个 RPC 调用中对消息进行排序。

```
// 注意stream关键词在什么地方
rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse) {
}
```

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/gRPC%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F02.png)

##### Server

```
func (s *StreamService) Record(stream pb.StreamService_RecordServer) error {
    for {
        r, err := stream.Recv()
        if err == io.EOF {
            return stream.SendAndClose(&pb.StreamResponse{Pt: &pb.StreamPoint{...}})
        }
        ...

    }

    return nil
}

```

##### Client

```
func printRecord(client pb.StreamServiceClient, r *pb.StreamRequest) error {
    stream, err := client.Record(context.Background())
    ...

    for n := 0; n < 6; n++ {
        stream.Send(r)
    }

    resp, err := stream.CloseAndRecv()
    ...

    return nil
}
```

</br>

#### Server streaming RPC（服务端流式RPC）

> Server streaming RPC：客户端发送单个请求，作为回报，服务器发送消息流。

其中双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照自己喜欢的顺序读写: 例如，服务器可以等待接收所有客户端消息后再写响应，或者可以交替读取消息然后写入消息，或者其他读写组合。每个流中的消息是有序的。

```
// 注意stream关键词在什么地方
rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
```

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/gRPC%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F03.png)

##### Server

```
func (s *StreamService) List(r *pb.StreamRequest, stream pb.StreamService_ListServer) error {
    for n := 0; n <= 6; n++ {
        stream.Send(&pb.StreamResponse{
            Pt: &pb.StreamPoint{
                ...
            },
        })
    }

    return nil
}


```

##### Client

```
func printLists(client pb.StreamServiceClient, r *pb.StreamRequest) error {
    stream, err := client.List(context.Background(), r)
    ...

    for {
        resp, err := stream.Recv()
        if err == io.EOF {
            break
        }
        ...
    }

    return nil
}


```

</br>

#### Bidirectional streaming RPC（双向流式RPC）

> 双向流式

Bidirectional streaming RPC：在双向流中，客户端和服务器都发送消息流。

```
// 注意stream关键词在什么地方
rpc BidiHello(stream HelloRequest) returns (stream HelloResponse){
}
```

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/gRPC%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F04.png)

##### Server

```
func (s *StreamService) Route(stream pb.StreamService_RouteServer) error {
    for {
        stream.Send(&pb.StreamResponse{...})
        r, err := stream.Recv()
        if err == io.EOF {
            return nil
        }
        ...
    }

    return nil
}


```

##### Client

```
func printRoute(client pb.StreamServiceClient, r *pb.StreamRequest) error {
    stream, err := client.Route(context.Background())
    ...

    for n := 0; n <= 6; n++ {
        stream.Send(r)
        resp, err := stream.Recv()
        if err == io.EOF {
            break
        }
        ...
    }

    stream.CloseSend()

    return nil
}


```

</br></br>

### 使用API

在 `.proto` 文件中的定义好服务之后，gRPC 提供了生成客户端和服务器端代码的 `protocol buffers `编译器插件。

我们使用这些插件可以根据需要生成`Java`、`Go`、`C++`、`Python`等语言的代码。我们通常会在客户端调用这些 API，并在服务器端实现相应的 API。

- 在服务器端，服务器实现服务声明的方法，并运行一个 gRPC 服务器来处理客户端发来的调用请求。gRPC 底层会对传入的请求进行解码，执行被调用的服务方法，并对服务响应进行编码。
- 在客户端，客户端有一个称为存根（stub）的本地对象，它实现了与服务相同的方法。然后，客户端可以在本地对象上调用这些方法，将调用的参数包装在适当的 protocol buffers 消息类型中—— gRPC 在向服务器发送请求并返回服务器的 protocol buffers 响应之后进行处理。



</br></br>

#### [下一篇就是gRPC入门示例](04.使用gRPC.md)



</br></br>

### 参考链接

- https://segmentfault.com/a/1190000039717888
- https://www.liwenzhou.com/posts/Go/gRPC/
- https://xy2401.com/local-docs/oschina/gRPC+%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%89%88_V1.0.html
- https://grpc.io/docs/what-is-grpc/introduction/
- https://www.cnblogs.com/xll1025/p/15753179.html