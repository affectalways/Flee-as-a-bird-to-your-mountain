# 03.gRPC核心概念、架构和生命周期

### 目录

- [概述](#概述)
- [gRPC调用模型](#gRPC调用模型)
- [gRPC调用方式](#gRPC调用方式)
- [使用API](#使用API)
- [使用protocol_buffers](#使用protocol_buffers)
- [protocol_buffers版本](#protocol_buffers版本)
- [参考链接](#参考链接)



</br></br>

### 概述

像许多 RPC 系统一样，gRPC 基于定义服务的思想，指定可以通过参数和返回类型远程调用的方法。**在gRPC里，客户端可以像调用本地方法一样直接调用其他机器上的服务端应用程序的方法**，帮助你更容易创建分布式应用程序和服务。与许多RPC系统一样，gRPC是基于定义一个服务，指定一个可以远程调用的带有参数和返回类型的的方法。

默认情况下，gRPC 使用[Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview)作为接口定义语言(IDL)来描述服务接口和有效负载消息的结构。可以根据需要使用其他的IDL代替。

例如，下面使用 `protocol buffers` 定义了一个`HelloService`服务。

```protobuf
service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
}
```

说明如下：

1. 定义一个表示请求的HelloRequest，其包含一个greeting字段表示请求内容
2. 定义一个表示响应的HelloResponse，其包含一个reply字段表示响应内容
3. 定义服务HelloService，其提供一个SayHello方法，以HelloRequest作为方法参数，并返回HelloResponse



</br></br>

### gRPC调用模型

![](D:\git_code\Flee-as-a-bird-to-your-mountain\gRPC\pictures\grpc1.svg)

1. 客户端（gRPC Stub）调用 A 方法，发起 RPC 调用。
2. 对请求信息使用 Protobuf 进行对象序列化压缩（IDL）。
3. 服务端（gRPC Server）接收到请求后，解码请求体，进行业务逻辑处理并返回。
4. 对响应结果使用 Protobuf 进行对象序列化压缩（IDL）。
5. 客户端接受到服务端响应，解码请求体。回调被调用的 A 方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果。



</br></br>

### gRPC调用方式

在gRPC中你可以定义四种类型的服务方法：

- ##### Unary RPC（普通RPC）

- ##### Client streaming RPC（客户端流式RPC）

- ##### Server streaming RPC（服务端流式RPC）

- ##### Bidirectional streaming RPC（双向流式RPC）

</br>

#### Unary RPC（普通RPC）

> Unary RPC：客户端发送单个请求并接收单个响应。

客户端向服务器发送一个请求，然后得到一个响应，就像普通的函数调用一样。

```
rpc SayHello(HelloRequest) returns (HelloResponse);
```

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/gRPC%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F01.png)



##### Server端

```go
type SearchService struct{}

func (s *SearchService) Search(ctx context.Context, r *pb.SearchRequest) (*pb.SearchResponse, error) {
    return &pb.SearchResponse{Response: r.GetRequest() + " Server"}, nil
}

const PORT = "9001"

func main() {
    server := grpc.NewServer()
    pb.RegisterSearchServiceServer(server, &SearchService{})

    lis, err := net.Listen("tcp", ":"+PORT)
    ...

    server.Serve(lis)
}
```

- 创建 gRPC Server 对象，你可以理解为它是 Server 端的抽象对象。
- 将 SearchService（其包含需要被调用的服务端接口）注册到 gRPC Server。的内部注册中心。这样可以在接受到请求时，通过内部的 “服务发现”，发现该服务端接口并转接进行逻辑处理。
- 创建 Listen，监听 TCP 端口。
- gRPC Server 开始 lis.Accept，直到 Stop 或 GracefulStop。

- 服务器流式 rpc，其中客户端向服务器发送请求，并获得一个流来读取一系列消息。客户端从返回的流中读取，直到没有更多的消息。gRPC 保证在单个 RPC 调用中的消息是有序的。

##### Client端

```go
func main() {
    conn, err := grpc.Dial(":"+PORT, grpc.WithInsecure())
    ...
    defer conn.Close()

    client := pb.NewSearchServiceClient(conn)
    resp, err := client.Search(context.Background(), &pb.SearchRequest{
        Request: "gRPC",
    })
    ...
}

```

- 创建与给定目标（服务端）的连接句柄。
- 创建 SearchService 的客户端对象。
- 发送 RPC 请求，等待同步响应，得到回调后返回响应结果。

</br>

#### Client streaming RPC（客户端流式RPC）

> Client streaming RPC：客户端发送消息流，服务器以单个消息响应。

其中客户端写入一系列消息并将其发送到服务器，同样使用提供的流。一旦客户端完成了消息的写入，它就等待服务器读取消息并返回响应。同样，gRPC 保证在单个 RPC 调用中对消息进行排序。

```
rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
```

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/gRPC%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F02.png)

##### Server

```
func (s *StreamService) Record(stream pb.StreamService_RecordServer) error {
    for {
        r, err := stream.Recv()
        if err == io.EOF {
            return stream.SendAndClose(&pb.StreamResponse{Pt: &pb.StreamPoint{...}})
        }
        ...

    }

    return nil
}

```

##### Client

```
func printRecord(client pb.StreamServiceClient, r *pb.StreamRequest) error {
    stream, err := client.Record(context.Background())
    ...

    for n := 0; n < 6; n++ {
        stream.Send(r)
    }

    resp, err := stream.CloseAndRecv()
    ...

    return nil
}
```

</br>

#### Server streaming RPC（服务端流式RPC）

> Server streaming RPC：客户端发送单个请求，作为回报，服务器发送消息流。

其中双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照自己喜欢的顺序读写: 例如，服务器可以等待接收所有客户端消息后再写响应，或者可以交替读取消息然后写入消息，或者其他读写组合。每个流中的消息是有序的。

```
rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
```

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/gRPC%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F03.png)

##### Server

```
func (s *StreamService) List(r *pb.StreamRequest, stream pb.StreamService_ListServer) error {
    for n := 0; n <= 6; n++ {
        stream.Send(&pb.StreamResponse{
            Pt: &pb.StreamPoint{
                ...
            },
        })
    }

    return nil
}


```

##### Client

```
func printLists(client pb.StreamServiceClient, r *pb.StreamRequest) error {
    stream, err := client.List(context.Background(), r)
    ...

    for {
        resp, err := stream.Recv()
        if err == io.EOF {
            break
        }
        ...
    }

    return nil
}


```

</br>

#### Bidirectional streaming RPC（双向流式RPC）

> 双向流式

Bidirectional streaming RPC：在双向流中，客户端和服务器都发送消息流。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/gRPC%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F04.png)

##### Server

```
func (s *StreamService) Route(stream pb.StreamService_RouteServer) error {
    for {
        stream.Send(&pb.StreamResponse{...})
        r, err := stream.Recv()
        if err == io.EOF {
            return nil
        }
        ...
    }

    return nil
}


```

##### Client

```
func printRoute(client pb.StreamServiceClient, r *pb.StreamRequest) error {
    stream, err := client.Route(context.Background())
    ...

    for n := 0; n <= 6; n++ {
        stream.Send(r)
        resp, err := stream.Recv()
        if err == io.EOF {
            break
        }
        ...
    }

    stream.CloseSend()

    return nil
}


```

</br></br>

### 使用API

在 `.proto` 文件中的定义好服务之后，gRPC 提供了生成客户端和服务器端代码的 `protocol buffers `编译器插件。

我们使用这些插件可以根据需要生成`Java`、`Go`、`C++`、`Python`等语言的代码。我们通常会在客户端调用这些 API，并在服务器端实现相应的 API。

- 在服务器端，服务器实现服务声明的方法，并运行一个 gRPC 服务器来处理客户端发来的调用请求。gRPC 底层会对传入的请求进行解码，执行被调用的服务方法，并对服务响应进行编码。
- 在客户端，客户端有一个称为存根（stub）的本地对象，它实现了与服务相同的方法。然后，客户端可以在本地对象上调用这些方法，将调用的参数包装在适当的 protocol buffers 消息类型中—— gRPC 在向服务器发送请求并返回服务器的 protocol buffers 响应之后进行处理。



</br></br>





</br></br>

### 参考链接

- https://segmentfault.com/a/1190000039717888
- https://www.liwenzhou.com/posts/Go/gRPC/
- https://xy2401.com/local-docs/oschina/gRPC+%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%89%88_V1.0.html
- https://grpc.io/docs/what-is-grpc/introduction/
- https://www.cnblogs.com/xll1025/p/15753179.html