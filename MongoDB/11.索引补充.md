# 11.索引补充

本篇文章将会说明以下几点。

- 什么是索引?
- 索引的优点与缺点
- 索引的建立
- 索引与非索引搜寻比较
- 不要使用索引的时机



### 什么是索引?

索引是什么?最常见的说法是，一本字典中，你要找单字，会先去前面的索引找他在第几页，是的这就是索引，可以帮助我们更快速的寻找到`document`，下面画张图来比较一下不使用索引和使用索引的搜寻概念图。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/11.%E7%B4%A2%E5%BC%9501.png)





### 索引的优缺点

索引竟然可以帮助我们着么快的找到目标，那是不是以后都用索引就好??着么可能!~
索引好归好，但他就像双刃刀，用的不好会gg的。

#### 优点

- 搜寻速度更(飞)快 ~
- 在使用分组或排度时更快 ~



#### 缺点

- 每次进行操作(新增、更新、删除)时，都会更费时，因为也要修改索引。
- 索引需要占据空间。





### 使用时机

所以根据以上的优缺点可知，不是什么都要建立索引的，通常只有下列时机才会使用。

- 搜寻结果占原`collection`越小，才越适合(下面会说明更清楚)。
- 常用的搜寻。
- 该搜寻造成性能瓶颈。
- 在经常需要排序的搜寻。
- 当索引性能大于操作性能时。





### 索引的建立

我们简单建立个索引使用范例。

```
db.tests.insert( {"x" : "hello"} )
```

然后这时我们建立`x`栏位的索引。

```
db.tests.ensureIndex({ "x" : 1 })
```

然后我们可以达行下列指令，来查看有没有建立成功。

```
db.tests.getIndexs()
```

结果如下，建立成功`x`的索引，其中`_id`那个是预设的，`mongodb`会自动帮`objectId`建立索引。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/11.%E7%B4%A2%E5%BC%9502.png)





### 索引与非索引搜寻比较

在`mongodb`中排序是非常的耗费内存资源，如果排序时内存耗费到`32mb`([这里](https://docs.mongodb.com/v3.0/tutorial/sort-results-with-indexes/))，`mongodb`就会报错，如果超出值，那么必须使用索引来获取经过排序的结果。

我们这里建立些资料，来比较看看两者的资源耗费不同点。

```
for (var i=0;i<100000;i++){
	db.test.insert({
		"x" : i
	})
}
```

然后建立`x`的索引。

```
db.test.ensureIndex({ "x" : 1 })
```

然后我们在有索引与无索引的情况下指行下列指令。

```
db.test.find({ "x" : {"$gt" : 50000}})
		.sort({"x" : -1})
		.explain("executionStats")
```

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/11.%E7%B4%A2%E5%BC%9503.png)



再来看看`有索引`的，由于有使用到索引进行排序，所以不需要在内存中进行排序。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/11.%E7%B4%A2%E5%BC%9504.png)

> 从上面两张图的结果可知有用索引的速度较快，也较省内存，但要注意并不是建立了索引就代表它一定会用索引排序，这在下一章复合索引会提到。





### 不要使用索引的时机

我们这边将使用时机的`搜寻结果占原collection越小，才越合适`来进行分析一下。

##### 我们来试试结果占原`collection`比大于60%会如何

我们这边将要来验证一下，在这种情况下，索引搜寻和全文搜寻(未使用索引)那个比较快。

首先来建立资料一百万笔，然后有`60%`的`x`都为`1`。

```
for (var i=0;i<1000000;i++){
	var value = (i<600000)?"1":"2" ;
	db.test.insert({
	  "x" : value
	})
}
```

然后建立`x`的索引。

```
db.test.ensureIndex({ "x" : 1 })
```

然后我们来比较看看两者的搜寻速度，我们要寻找`x`为`1`的。

首先看看没有用索引的速度，嗯…`418ms`

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/11.%E7%B4%A2%E5%BC%9505.png)

再來看看有索引的速度，嗯…657ms

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/11.%E7%B4%A2%E5%BC%9506.png)

从上面结果可看出有用索引的比较慢，主要原因为他要先去扫索引然后，再去找全文，正常情况下索引会比较快，但是如果`結果`占`原collection`比过多时就会发生索引反而比较慢。

所以记好当你要找的结果可能会占你原资料太多部份的，请不要用索引 





### 结语

索引是一把双刃刀，用的好的话效能非常的好，用的不好就很差了





### 参考链接

- https://docs.mongodb.com/v3.0/tutorial/sort-results-with-indexes/
- https://kknews.cc/zh-tw/other/xpp5mg.html
- http://www.mongoing.com/eshu_explain3
- https://docs.mongodb.com/v3.0/core/indexes-introduction/
- https://ithelp.ithome.com.tw/articles/10185673