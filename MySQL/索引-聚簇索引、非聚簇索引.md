# 聚簇索引、非聚簇索引

> **聚簇索引与非聚簇索引的区别是：叶节点是否存放一整行记录**

InnoDB 主键使用的是聚簇索引；

MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。

#### 

聚簇索引(Clustered Index)并不是一种新的数据结构，只是B树索引的一种存储方式。

聚簇索引与非聚簇对比如下图

![](https://upload-images.jianshu.io/upload_images/3190591-fdd992e6ec02ef06.png?imageMogr2/auto-orient/strip|imageView2/2/w/662/format/webp)

> 聚簇索引，它的数据行实际上存放在索引的叶子页(leaf page)中。因为无法同时把数据行存放在两个不同的地方，所以**一个表只能有一个聚簇索引**（不过，覆盖索引可以模拟多个聚簇索引的情况）。
>
> 如果表中没有定义主键，InnoDB会选择一个所有列非空的Unique索引作为聚簇索引。
>
> 如果表中既没有主键也没有非空的唯一索引，InnoDB内部会生成一个名为`GEN_CLUST_INDEX`的隐式聚簇索引。这个隐式的聚簇索引中包含每个数据行的RowID，并以RowID作为隐式主键进行排序。RowID是一个6字节的字段，并随着新行的插入而单调递增，隐式索引中的数据行在物理结构上是按插入顺序顺序存储的。
>
> **InnoDB的二级索引会在叶子结点保存主键**。
>
> 当通过二级索引查找时，**InnoDB需要通过二级索引的叶子结点获得对应的主键，然后根据主键从主键索引中找对应的行**。也就是说**InnoDB查找数据行会经过两个B树**。这样做有个好处就是**减少了数据行移动或数据页分裂时二级索引的维护工作**，但是查找速度会略微变慢，有一种解决方法是实现**索引覆盖，让二级索引直接覆盖所需的查询字段**，这样就没必要查找数据行，也就没必要走主键索引了。

**聚簇索引的二级索引：叶子节点不会保存引用的行的物理位置，而是保存行的主键值。**

1. **聚簇索引表**（左图），表数据是和主键一起存储的
   - 主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。
   - 使用的是B+树作为索引的存储结构，非叶子节点都是索引，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。
   - 叶子节点上的数据是主键与具体记录(数据内容)。
2. **非聚簇索引表**（右图），表数据和索引是分成两部分存储的，
   - 主键索引和二级索引存储上没有任何区别。
   - 使用的是B+树作为索引的存储结构，所有的节点都是索引
   - 叶子节点存储的是索引+索引对应的记录的数据。
   - MyISAM的B+Tree的叶子节点上的data，并不是数据本身，而是**数据存放的地址。**



对于**聚簇索引**的**存储引擎**，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的，如果主键不是自增id，可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。

对于非聚簇索引的存储引擎，**表数据存储顺序与索引顺序无关**，**叶结点包含索引字段值及指向数据页数据行的逻辑指针**，其行数量与数据表行数据量一致。



#### #

### 聚簇索引的优点

1. 聚簇索引将索引和数据行保存在同一个B-Tree中，查询通过聚簇索引可以直接获取数据，而非聚簇索引要进行多次I/O，所以聚簇索引通常比非聚簇索引查找更快。
2. 聚簇索引对主键范围查询的效率很高，因为其数据是按照主键排列的
3. 二级索引使用索引覆盖可以直接使用叶节点的主键值。



### 聚簇索引的缺点

1. 聚簇索引最大限度地提高了I/O密集型应用的性能，但如果数据都存放在内存中，则访问顺序就不那么重要了，聚簇索引也没什么优势。
2. 插入速度严重依赖于插入顺序。按照主键顺序往InnoDB中进行数据导入是最快的。如果不是按照主键插入，最好在导入完成后使用[`OPTIMIZE TABLE`](https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html)命令重新组织一下表。
3. 聚簇索引在插入新行和更新主键时，可能导致“页分裂”问题：当插入到某个已满的叶子结点时，B+树会分裂成两个页来容纳新插入的行数据。页分裂会导致表占用更多的磁盘空间（不要用UUID或随机数做主键，而应该使用单调递增的值做主键）。
4. 聚簇索引可能导致全表扫描速度变慢，因为可能需要加载物理上相隔较远的页到内存中（需要耗时的磁盘寻道操作）。
5. 二级索引访问数据行需要两次索引查找，由于二级索引保存了主键列，二级索引会占更大的空间(所以选用一个短主键是有利的)。



### #

InnoDB通过主键聚簇数据，整个聚簇索引就是一张完整的表。MyISAM存储引擎的数据相对简单。

MyISAM的数据行和索引是分开存储的：数据文件以`.MYD`为后缀，索引文件以`.MYI`为后缀(Innodb只有一个`.idb`文件)。

数据行按照数据插入顺序存储在数据文件中，数据行的存储支持多种[行存储格式](https://dev.mysql.com/doc/refman/5.7/en/myisam-table-formats.html)(ROW_FORMAT)。

**MyISAM没有聚簇索引，主键索引和二级索引工作方式是一样的：叶子结点存储数据行在数据文件中的物理偏移量(行指针)**

![](http://tva1.sinaimg.cn/large/bda5cd74gy1frp7htdkc2j20fn0cxabx.jpg)

### [#](https://blog.hufeifei.cn/2018/05/27/DB/MySQL性能优化[理论篇]-聚簇索引和非聚簇索引,InnoDB和MyISAM/#myisam-you-dian)MyISAM优点

1. 读取数据行的速度快，特别是当数据行长度固定的时候。

2. 数据行插入容易，新行直接追加到数据文件末尾。

   

### [#](https://blog.hufeifei.cn/2018/05/27/DB/MySQL性能优化[理论篇]-聚簇索引和非聚簇索引,InnoDB和MyISAM/#myisam-que-dian)MyISAM缺点

1. 删除操作必须留出空白区域，否则后面的行数据偏移将会发生变化。正因如此当大量删除MyISAM表数据后，数据文件大小不会发生变化，所以要定期执行`OPTIMIZE TABLE`操作对MyISAM碎片空间进行整理。
2. 修改操作数据行长度如果变短，也会留白；数据行如果变长，数据将会分段存储。
