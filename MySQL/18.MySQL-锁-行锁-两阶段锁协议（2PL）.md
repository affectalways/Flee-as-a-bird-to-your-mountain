# 18.MySQL-锁-行锁-两阶段锁协议（2PL）

**目录**

- [行锁概要](#行锁概要)
- [背景](#背景)
- [例子](#例子)
- [总结](#总结)
- [参考链接](#参考链接)



## 行锁概要

​		MySQL 的行锁是在引擎层由各个**引擎实现**的。

​		并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。

​		我们今天就主要来聊聊 InnoDB 的行锁，以及如何通过减少锁冲突来提升业务并发度。

​		顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。

​		当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如两阶段锁。





## 背景

​		经常听到别人说`2PL`，猛的一听当时真的是一脸懵逼的感觉，啥意思？`2PL`是什么玩意？后来又听人说`两阶段锁协议`，这个又是什么？

​		后来才知这是MySQL中的一个术语：**2PL(Two-phase locking)**，翻译成中文就是两阶段锁协议。





## 例子

​		先举个例子。在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。

![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/13.%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8D%8F%E8%AE%AE.jpg?raw=true)

​		这个问题取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放。

​		`事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。`

​		事务 A 持有的两个记录的行锁，都是在 commit 的时候才释放的。

​		也就是说，**在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议（**分为加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。）**

​		知道了这个设定，对我们使用事务有什么帮助呢？那就是，**如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。**

​	



## 总结

​		在MySQL中，两阶段锁协议的含义是：当一个事务获取到了某一个数据库对象的锁之后，并不是当前事务不需要操作它了之后，这个锁就会马上释放掉，这个锁会一直被这个事务持有，直到这个事务被提交或回滚后，这个锁才会被释放掉。所以，在当前事务还没有结束的时候，任何其他事务尝试获取这个锁的时候，都会被阻塞。知道当前事务提交或回滚后，前提事务才可以获取到这把锁。

​		这就是MySQL中2PL两阶段锁协议的含义。它在事务并发的时候，为数据的一致性提供有力的保障。





## 参考链接

- https://www.modb.pro/db/74023
- https://god-jiang.github.io/2021/03/12/MySQL%E7%9A%84%E8%A1%8C%E9%94%81/
- https://shaojunying.github.io/eee6ff7df0344e9ca749bb9b6545e960.html