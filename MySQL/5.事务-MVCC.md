# 5.事务-MVCC

> InnoDB存储引擎的默认事务隔离级别**可重复读(`repeatable read`)**（简称RR），是通过 "**行级锁+MVCC**"一起实现的。
>
> 需要注意的是，在SQL标准中，RR是无法避免幻读问题的，但是**InnoDB实现的RR避免了幻读问题**。

​		

> RR解决脏读、不可重复读、幻读等问题，使用的是MVCC



## 定义

​		**MVCC**（Multi-Version Concurrency Control），即多版本并发控制。指的是一种提高并发的技术。最早期的数据库系统，只有读读之间可以并发，读写、写读、写写都要阻塞。引入MVCC之后，只有**写写之间相互阻塞**，其他三种操作都可以并行，这样大幅度提高了`InnoDB`的并发性能。

​		在内部实现中，`InnoDB`通过`undo log`保存每条数据的多个版本，并且能够提供数据历史版本给用户读，每个事务读到的数据版本可能是不一样的。在同一个事务中，用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改。

​		简单来说，`MVCC`是**维持一个数据的多个版本，使得读写操作没有冲突**。

> MVCC在`read committed`和`repeatable read`两个事务隔离级别下工作。

> MVCC最大的优点是读不加锁，因此读写不冲突，并发性能好。



## 案例

​		下面的例子很好的体现了MVCC的特点：在同一时刻，不同的事务读取到的数据可能是不同的(即多版本)——在T5时刻，事务A和事务C可以读取到不同版本的数据。

![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/5.%E4%BA%8B%E5%8A%A1-MVCC-%E6%A1%88%E4%BE%8B1.png?raw=true)



## 实现

InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构：

- 隐藏字段
- 基于undo log的版本链
- ReadView结构



#### 隐藏字段

`InnoDB`存储引擎在**每行**数据的后面添加了三个隐藏字段，如下图所示：

![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/5.%E4%BA%8B%E5%8A%A1-MVCC-%E5%AE%9E%E7%8E%B0-%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5.png?raw=true)

1. `DB_TRX_ID`(6字节)：表示最近一次对**本行**做修改(`insert`或`update`)的事务ID。至于`delete`操作，`InnoDB`认为是一个`update`操作，不过会更新一个另外的删除位，将行标识为deleted。并非真正删除。
2. `DB_ROLL_PTR`(7字节)：回滚指针，指向当前记录行的`undo log`信息。
3. `DB_ROW_ID`(6字节)：随着新行插入而单调递增的行ID。当表没有主键或唯一非空索引时，`InnoDB`就会使用这个行ID自动产生聚集索引。这个`DB_ROW_ID`跟`MVCC`关系不大。



#### Undo Log

`undo log`中存储的是老版本数据，当一个事务需要读取记录行时，如果当前记录行不可见，可以顺着`undo log`链表找到满足其可见性条件的记录行版本。

对数据的变更操作主要包括`insert/update/delete`，在`InnoDB`中，`undo log`分为如下两类：

- `insert undo log`: 事务对`insert`新记录时产生的`undo log`, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。
- `update undo log`: 事务对记录进行`delete`和`update`操作时产生的`undo log`，不仅在事务回滚时需要，快照读也需要，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被`purge`线程删除。

> `Purge`线程：为了实现`InnoDB`的`MVCC`机制，更新或者删除操作都只是设置一下旧记录的`deleted_bit`，并不真正将旧记录删除。为了节省磁盘空间，`InnoDB`有专门的`purge`线程来清理`deleted_bit`为`true`的记录。`purge`线程自己也维护了一个`read view`，如果某个记录的`deleted_bit`为`true`，并且`DB_TRX_ID`相对于`purge`线程的`read view`可见，那么这条记录一定是可以被安全清除的。

不同事务或者相同事务的对同一记录行的修改形成的`undo log`如下图所示：

![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/5.%E4%BA%8B%E5%8A%A1-MVCC-%E5%AE%9E%E7%8E%B0-undolog.png?raw=true)

> 可见链首就是最新的记录，链尾就是最早的旧记录。



#### ReadView结构

`Read View`(读视图)提供了某一时刻事务系统的快照，主要是用来做`可见性`判断的, 里面保存了"对本事务不可见的其他活跃事务"。

MySQL`5.7`源码中对`Read View`定义如下(详情见`https://github.com/mysql/mysql-server/blob/5.7/storage/innobase/include/read0types.h#L306`)：

```
class ReadView {
	private:
		/** The read should not see any transaction with trx id >= this
		value. In other words, this is the "high water mark". */
		trx_id_t	m_low_limit_id;

		/** The read should see all trx ids which are strictly
		smaller (<) than this value.  In other words, this is the
		low water mark". */
		trx_id_t	m_up_limit_id;

		/** trx id of creating transaction, set to TRX_ID_MAX for free
		views. */
		trx_id_t	m_creator_trx_id;

		/** Set of RW transactions that was active when this snapshot
		was taken */
		ids_t		m_ids;

		/** The view does not need to see the undo logs for transactions
		whose transaction number is strictly smaller (<) than this value:
		they can be removed in purge if not needed by other views */
		trx_id_t	m_low_limit_no;

		/** AC-NL-RO transaction view that has been "closed". */
		bool		m_closed;

		typedef UT_LIST_NODE_T(ReadView) node_t;

		/** List of read views in trx_sys */
		byte		pad1[64 - sizeof(node_t)];
		node_t		m_view_list;
};
```

重点解释下面几个变量（建议仔细看上面的源码注释，以下仅为个人理解）：

（1） **m_ids**：Read View 创建时其他未提交的活跃事务ID列表。具体说来就是创建`Read View`时，将当前未提交事务ID记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。

> 注意：该事务ID列表不包括当前事务自己和已提交的事务。

（2）**m_low_limit_id**：某行数据的 DB_TRX_ID >= m_low_limit_id 的任何版本对该查询`不可见`。那么这个值是怎么确定的呢？其实就是读的时刻出现过的最大的事务ID+1，即下一个将被分配的事务ID。见`https://github.com/mysql/mysql-server/blob/5.7/storage/innobase/read/read0read.cc#L459`

```
/**
Opens a read view where exactly the transactions serialized before this
point in time are seen in the view.
@param id		Creator transaction id */

void
ReadView::prepare(trx_id_t id)
{
	m_creator_trx_id = id;

	m_low_limit_no = m_low_limit_id = trx_sys->max_trx_id;
}
```

`max_trx_id`见`https://github.com/mysql/mysql-server/blob/5.7/storage/innobase/include/trx0sys.h#L576`中的描述，翻译过来就是“还未分配的最小事务ID”，也就是下一个将被分配的事务ID。（注意，`m_low_limit_id`并不是活跃事务列表中最大的事务ID）

```cpp
struct trx_sys_t {
/*!< The smallest number not yet
					assigned as a transaction id or
					transaction number. This is declared
					volatile because it can be accessed
					without holding any mutex during
					AC-NL-RO view creation. */
	volatile trx_id_t max_trx_id;
}
```

（3）**m_up_limit_id**：某行数据的 DB_TRX_ID < m_up_limit_id 的所有版本对该查询 **可见**。同样这个值又是如何确定的呢？`m_up_limit_id`是活跃事务列表`m_ids`中最小的事务ID，如果trx_ids为空，则`m_up_limit_id`为`m_low_limit_id`。代码见`https://github.com/mysql/mysql-server/blob/5.7/storage/innobase/read/read0read.cc#L485`

```cpp
void
ReadView::complete()
{
	/* The first active transaction has the smallest id. */
	m_up_limit_id = !m_ids.empty() ? m_ids.front() : m_low_limit_id;

	ut_ad(m_up_limit_id <= m_low_limit_id);

	m_closed = false;
}
```

这样就有下面的可见性比较算法了。代码见`https://github.com/mysql/mysql-server/blob/5.7/storage/innobase/include/read0types.h#L169`

```cpp
/** Check whether the changes by id are visible.
	@param[in]	id	transaction id to check against the view
	@param[in]	name	table name
	@return whether the view sees the modifications of id. */
bool changes_visible(
	trx_id_t		id,
	const table_name_t&	name) const
	MY_ATTRIBUTE((warn_unused_result))
{
	ut_ad(id > 0);


	/* 假如 trx_id 小于 Read view 限制的最小活跃事务ID m_up_limit_id 或者等于正在创建的事务ID m_creator_trx_id
     * 即满足事务的可见性.
     */
	if (id < m_up_limit_id || id == m_creator_trx_id) {
		return(true);
	}

	/* 检查 trx_id 是否有效. */
	check_trx_id_sanity(id, name);

	if (id >= m_low_limit_id) {
		/* 假如 trx_id 大于等于m_low_limit_id, 即不可见. */
		return(false);

	} else if (m_ids.empty()) {
		/* 假如目前不存在活跃的事务，即可见. */
		return(true);
	}

	const ids_t::value_type*	p = m_ids.data();

	/* 利用二分查找搜索活跃事务列表
	 * 当 trx_id 在 m_up_limit_id 和 m_low_limit_id 之间
   * 如果 id 在 m_ids 数组中, 表明 ReadView 创建时候，事务处于活跃状态，因此记录不可见.
   */
	return (!std::binary_search(p, p + m_ids.size(), id));
}
```

![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/5.%E4%BA%8B%E5%8A%A1-MVCC-%E5%AE%9E%E7%8E%B0-readview.png?raw=true)

完整梳理一下整个过程。

在`InnoDB`中，创建一个新事务后，执行第一个`select`语句的时候，`InnoDB`会创建一个快照（`read view`），快照中会保存系统当前不应该被本事务看到的其他活跃事务id列表（即`m_ids`）。当用户在这个事务中要读取某个记录行的时候，`InnoDB`会将该记录行的`DB_TRX_ID`与该`Read View`中的一些变量进行比较，判断是否满足可见性条件。

假设当前事务要读取某一个记录行，该记录行的`DB_TRX_ID`（即最新修改该行的事务ID）为`trx_id`，`Read View`的活跃事务列表`m_ids`中最早的事务ID为`m_up_limit_id`，将在生成这个`Read Vew`时系统出现过的最大的事务ID+1记为`m_low_limit_id`（即还未分配的事务ID）。

具体的比较算法如下:

1. 如果`trx_id < m_up_limit_id`,那么表明“最新修改该行的事务”在“当前事务”创建快照之前就提交了，所以该记录行的值对当前事务是可见的。跳到步骤5。
2. 如果`trx_id >= m_low_limit_id`, 那么表明“最新修改该行的事务”在“当前事务”创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤4。
3. 如果`m_up_limit_id <= trx_id < m_low_limit_id`, 表明“最新修改该行的事务”在“当前事务”创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表trx_ids进行查找（源码中是用的二分查找，因为是有序的）

(1) 如果在活跃事务列表`m_ids`中能找到id为`trx_id`的事务，表明①在“当前事务”创建快照前，“该记录行的值”被“id为`trx_id`的事务”修改了，但没有提交；或者②在“当前事务”创建快照后，“该记录行的值”被“id为`trx_id`的事务”修改了（不管有无提交）；这些情况下，这个记录行的值对当前事务都是不可见的，跳到步骤4；

(2) 在活跃事务列表中找不到，则表明“id为`trx_id`的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见，跳到步骤5。

1. 在该记录行的`DB_ROLL_PTR`指针所指向的`undo log`回滚段中，取出最新的的旧事务号`DB_TRX_ID`, 将它赋给`trx_id`，然后跳到步骤1重新开始判断。
2. 将该可见行的值返回。



## **参考链接**

- [《MySQL中MVCC的正确打开方式（源码佐证）》](https://blog.csdn.net/Waves___/article/details/105295060) 
- [《InnoDB事务分析-MVCC》](http://www.leviathan.vip/2019/03/20/InnoDB的事务分析-MVCC/)
- [《Innodb中的事务隔离级别和锁的关系》](https://tech.meituan.com/2014/08/20/innodb-lock.html) 
- [[深入学习MySQL事务：ACID特性的实现原理 ](https://www.cnblogs.com/kismetv/p/10331633.html)](https://www.cnblogs.com/kismetv/p/10331633.html)
- https://www.cnblogs.com/bytesfly/p/mysql-transaction-innodb-mvcc.html

