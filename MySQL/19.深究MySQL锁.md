# 19.深究MySQL锁

**目录**

- [锁类型](#锁类型)
- [共享锁、排他锁](#共享锁、排他锁)
- [记录锁](#记录锁)
- [间隙锁](#间隙锁)
- [临键锁](#临键锁)
- [意向锁](#意向锁)
- [插入意向锁](#插入意向锁)
- [参考链接](#参考链接)





### 锁类型

![img](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/17.MySQL-%E9%94%81-InnoDB%E9%94%81%E7%B1%BB%E5%9E%8B1.png)





### 共享锁、排他锁

​		MySQL InnoDB 引擎实现了标准的`行级别锁：共享锁( S lock ) 和排他锁 ( X lock )`

> 1. 不同事务可以同时对同一行记录加 S 锁。
> 2. 如果一个事务对某一行记录加 X 锁，其他事务就不能加 S 锁或者 X 锁，从而导致锁等待。

​		如果事务 T1 持有行 r 的 S 锁，那么另一个事务 T2 请求 r 的锁时，会做如下处理:

> 1. T2 请求 S 锁立即被允许，结果 T1 T2 都持有 r 行的 S 锁
> 2. T2 请求 X 锁不能被立即允许

​		如果 T1 持有 r 的 X 锁，那么 T2 请求 r 的 X、S 锁都不能被立即允许，T2 必须等待 T1 释放 X 锁才可以，因为 X 锁与任何的锁都不兼容。共享锁和排他锁的兼容性如下所示：

![img](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/17.MySQL-%E9%94%81-InnoDB%E9%94%81%E7%B1%BB%E5%9E%8B2.png)

简而言之，就是读锁会阻塞写(X)，但是不会堵塞读(S)。而写锁则会把读(S)和写(X)都堵塞



在 InnoDB 存储引擎中，默认情况下使用的快照读（对于普通 select 语句，innodb 不会加任何锁），如果想在select操作的时候加上 S锁 或者 X锁，需要我们手动加锁，语句如下：

- 加共享锁（S）

> **select * from table_name where ... lock in share mode**：对读取的行记录加一个共享锁，其他事务可以向被锁定的记录加共享锁，但是想要加排它锁。则会被阻塞。

- 加排它锁（X)

> **select * from table_name where ... for update**：对读取的行记录加一个排它锁，其他事务想要在这些行上加任何锁都会被阻塞
>
> 对于 update、delete 和 insert 语句， 会自动给涉及数据集加排它锁（X）；



> **一般普通的select语句，InnoDB不加任何锁，我们称之为快照读**
>
> - select * from test;
>
>   
>
> **通过加S锁和X锁的select语句或者插入/更新/删除操作，我们称之为当前读**
>
> - select * from test lock in share mode;
> - select * from test for update;
> - insert into test values(…);
> - update test set …;
> - delete from test …;
>
> 
>
> 特殊说明：**以上的当前读，读取的都是记录的最新版本。对读取记录都会加锁，除了第一条语句lock in share mode是对记录加S锁（共享锁）外，其他的操作都是加X锁（排他锁）**。





### 记录锁

​		记录锁其实很好理解，对表中的记录加锁，叫做记录锁，简称行锁。比如

```
SELECT * FROM `test` WHERE `id`=1 FOR UPDATE;
```

​		它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行。

​		需要注意的是：

- id 列必须为唯一索引列或主键列，否则上述语句加的锁就会变成临键锁(有关临键锁下面会讲)。
- 同时查询语句必须为精准匹配（=），不能为 >、<、like等，否则也会退化成临键锁。

其他实现

在通过 **主键索引** 与 **唯一索引** 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：

```
-- id 列为主键列或唯一索引列 
UPDATE SET age = 50 WHERE id = 1;
```

**记录锁是锁住记录，锁住索引记录，而不是真正的数据记录.**

如果要锁的列没有索引，进行全表记录加锁

> 记录锁也是排它(X)锁,所以会阻塞其他事务对其插入、更新、删除。





### 间隙锁

​		`间隙锁（gap lock）`是 Innodb 在 RR(可重复读) 隔离级别 下为了解决`幻读问题`时引入的锁机制。间隙锁是innodb中行锁的一种。

​		请务必牢记：使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。

​		举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：

```
 SELECT * FROM emp WHERE empid > 100 FOR UPDATE
```

​		当我们用条件检索数据，并请求共享或排他锁时，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。

​		这个时候如果你插入empid等于102的数据的，如果那边事物还没有提交，那你就会处于等待状态，无法插入数据。

​		有关间隙锁所需讲的东西还是蛮多的，我会单独写一篇文章来分析间隙锁，并在文章中附上完整的示例。

> 锁住一个间隙以防止插入。假设索引列有2, 4, 8 三个值，如果对 4 加锁，那么也会同时对(2,4)和(4,8)这两个间隙加锁。其他事务无法插入索引值在这两个间隙之间的记录。但是，间隙锁有个例外:
>
> > 1. 如果索引列是唯一索引，那么只会锁住这条记录(只加行锁)，而不会锁住间隙。
> > 2. 对于联合索引且是唯一索引，如果 where 条件只包括联合索引的一部分，那么依然会加间隙锁。
>





### 临键锁

​		`临键锁next-key lock` 是**记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁**。也可以理解为一种特殊的间隙锁。在 RR 隔离级别下，通过临建锁可以解决`幻读`的问题。每个数据行上的`非唯一索引`列上都会存在一把`临键锁`，当某个事务持有该数据行的`临键锁`时，会锁住一段`左开右闭区间`的数据，需要强调的一点是：

InnoDB 中**行级锁**是基于索引实现的。

```
临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁
```

假设有如下表：id主键, age 普通索引

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/18.%E6%B7%B1%E7%A9%B6MySQL%E9%94%811.png)

该表中 age 列潜在的临键锁有：

```
(-∞, 10],
(10, 24],
(24, 32],
(32, 45],
(45, +∞],
```

在事务 A 中执行如下命令：

```
-- 根据非唯一索引列 UPDATE 某条记录 
UPDATE table SET name = Vladimir WHERE age = 24; 
-- 或根据非唯一索引列 锁住某条记录 
SELECT * FROM table WHERE age = 24 FOR UPDATE;
```

不管执行了上述 SQL 中的哪一句，之后如果在事务 B 中执行以下命令，则该命令会被阻塞：

```
INSERT INTO table VALUES(100, 26, 'tianqi');
```

很明显，事务 A 在对 age 为 24 的列进行 UPDATE 操作的同时，也获取了 (10, 32] 这个区间内的**临键锁**。

##### 总结

这里对 记录锁、间隙锁、临键锁 做一个总结

- InnoDB 中的行锁的实现依赖于索引，一旦某个加锁操作没有使用到索引，那么该锁就会退化为`表锁`。
- 记录锁存在于包括主键索引在内的唯一索引中，锁定单条索引记录。
- 间隙锁存在于非唯一索引中，锁定开区间范围内的一段间隔，它是基于临键锁实现的。
- 临键锁存在于非唯一索引中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的间隙锁，锁定一段左开右闭的索引区间。





### 意向锁

​	意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以在需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。

意向锁又分为 意向共享锁（IS）和 意向排他锁（IX）



##### 意向共享(IS)锁

事务有意向对表中的某些行加**共享锁**（S锁）

```
-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 
SELECT column FROM table ... LOCK IN SHARE MODE;
```



##### 意向排他(IX)锁

事务有意向对表中的某些行加**排他锁**（X锁）

```
-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
 SELECT column FROM table ... FOR UPDATE;
```



首先我们要明白四点

- 意向共享锁（IS）和 意向排他锁（IX）都是**表锁**。
- 意向锁是一种 **不与行级锁冲突的表级锁**，这一点非常重要。
- 意向锁是 InnoDB 自动加热， 不需用户干预。
- 意向锁是在 InnoDB 下存在的内部锁，对于MyISAM 而言 没有意向锁之说。

这里就会有疑惑，既然前面已经有了共享锁（S锁）、排它锁（X锁）。那么为什么需要引入意向锁呢？它能解决什么问题呢？

我们可以理解 意向锁 存在的目的就是 为了让 InnoDB 中的行锁和表锁能更高效的共存。

为什么这么说，我们来举一个例子。

举例

下面有一张表 **InnoDB RR隔离级别 id是主键**

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/17.意向锁1.jpg)

在讲解插入意向锁之前，先来思考一个问题

```
SELECT * FROM users WHERE id = 6 FOR UPDATE;
```

事务 B 想要获取users表的**表锁**：

```
LOCK TABLES users READ;
```

因为共享锁与排他锁互斥，所以事务 B 在视图对 users 表加共享锁的时候，必须保证：

- 当前没有其他事务持有人 users 表的排他锁。
- 当前没有其他事务持有 users 表中任意一行的排他锁 。

为了检测是否满足第二个条件，事务 B 必须在确保users表不存在任何**排他锁**的前提下，去检测表中的**每一行是否存在排他锁**。很明显这是一个效率很差的做法，但是有了**意向锁**之后，情况就不一样了：事务B只要看表上有没有

意向共享锁，有则说明表中有些行被**共享行锁**锁住了，因此，事务B申请表的写锁会被阻塞。这样是不是就高效多了。

这也解释就应该清楚，为什么有意向锁这个东西存在了。

我们可以举个生活中的例子，再来理解下为什么需要存在意向锁。

打个比方，就像有个游乐场，很多小朋友进去玩，看门大爷如果要下班锁游乐场的门(**加表锁**)，他必须确保每个角落都要去检查一遍，确保每个小朋友都离开了(**释放行锁**)，才可以锁门。

假设锁门是件频繁发生的事情，大爷就会非常崩溃。那大爷想了一个办法，每个小朋友进入，就把自己的名字写在本子上，小朋友离开，就把自己的名字划掉，那大爷就能方便掌握有没有小朋友在游乐场里，不必每个角落都去寻找一遍。

例子中的“小本子”，就是**意向锁**，他记录的信息并不精细，他只是提醒大爷，有人在屋里。

这里我们再来看下 共享(S)锁、排他(X)锁、意向共享锁（IS）、意向排他锁（IX）的兼容性

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/17.意向锁2.jpg)



可以看出 **意向锁之间是互相兼容的**。那存在的意义是啥？

意向锁不会为难意向锁。也不会为难行级排他(X)/共享(X)锁，它的存在是为难表级排他(X)/共享(X)锁。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/17.MySQL-锁-InnoDB锁类型-2.png)

注意**这里的排他(X)/共享(S)锁指的都是表锁！意向锁不会与行级的共享/排他锁互斥！** 行级别的X和S按照上面的兼容性规则即可。

意向锁与意向锁之间永远是兼容的，因为当你不论加行级的X锁或S锁，都会自动获取表级的IX锁或者IS锁。也就是你有10个事务，对不同的10行加了行级X锁，那么这个时候就存在10个IX锁。

这10IX存在的目的是啥呢，就是假如这个时候有个事务，想对整个表加排它X锁,那它不需要遍历每一行是否存在S或X锁，而是看有没有存在意向锁，只要存在一个意向锁，那这个事务就加不了表级排它X锁，要等上面10个IX全部释放才行。





### 插入意向锁

​		在讲解插入意向锁之前，先来思考一个问题

​		下面有张表 id主键，age普通索引

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/18.%E6%B7%B1%E7%A9%B6MySQL%E9%94%815.png)

首先**事务 A** 插入了一行数据，并且没有 **commit**：

```
INSERT INTO users SELECT 4, 'Bill', 15;
```

随后**事务 B** 试图插入一行数据：

```
INSERT INTO users SELECT 5, 'Louis', 16;
```

请问：

1、事务A使用了什么锁？

2、 **事务 B** 是否会被**事务 A** 阻塞？

​		**插入意向锁**是在插入一条记录行前，由 INSERT 操作产生的一种**间隙锁**。

​		该锁用以表示插入**意向**，当多个事务在**同一区间（gap）**插入**位置不同**的多条数据时，事务之间不**需要互相等待**。

​		假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别试图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占的（排他）锁前，都会获取（4，7]之间的**间隙锁**，但是因为数据行之间并不冲突，所以两个事务之间并**不会产生冲突**（阻塞等待）。

​		总结来说，**插入意向锁** 的特性可以分成两部分：

- 插入意向锁是一种特殊的间隙锁 —— 间隙锁可以锁定开区间内的部分记录。
- 插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（主键、唯一索引）不冲突，那么事务之间就不会出现冲突等待。

> 虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁而插入意向锁是行锁。

​		现在我们可以回答开头的问题了：

1、使用插入意向锁与记录锁。
2、事务 A 不会阻塞事务 B。

​		为什么不用间隙锁？

​		如果只是使用普通的间隙锁会怎么样呢？我们在看事务A,其实它一共获取了3把锁

- id 为 4 的记录行的**记录锁**。
- age 区间在（10，15] 的**间隙锁**。
- age 区间在（15，20] 的**间隙锁**。

最终，**事务 A** 插入了该行数据，并锁住了（10，20] 这个区间。

随后**事务 B** 试图插入一行数据：

```
INSERT INTO users SELECT 5, 'Louis', 16;
```

因为 16 位于（15，20] 区间内，而该区间内又存在一把**间隙锁**，所以**事务 B** 别说想申请自己的**间隙锁**了，它甚至不能获取该行的**记录锁**，自然只能乖乖的等待 **事务 A**结束，才能执行插入操作。

很明显，这样做事务之间将会频发陷入**阻塞等待**，插入的并发性非常之差。这时如果我们再去回想我们刚刚讲过的**插入意向锁**，就不难发现它是如何优雅的解决了**并发插入**的问题。



##### 总结

- InnoDB在RR的事务隔离级别下，使用插入意向锁来**控制和解决并发插入**。
- 插入意向锁是一种特殊的**间隙锁**。
- 插入意向锁在锁定区间相同但记录行本身不冲突的情况下**互不排斥**。





### 参考链接

- [重点！！！](https://mp.weixin.qq.com/s/9EtN8lN3dfRwfwMZR_B_0A)

- [https://z.itpub.net/article/detail/7B944ED17C0084CF672A47D6E938B750#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81,to%20get%20lock...%20%E3%80%82](https://z.itpub.net/article/detail/7B944ED17C0084CF672A47D6E938B750#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81,to%20get%20lock...%20%E3%80%82)
