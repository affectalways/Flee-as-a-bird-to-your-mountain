# 17.行锁

##### 目录

- [行锁定义](#行锁定义)
- [支持行锁的存储引擎](#支持行锁的存储引擎)
- [行锁类型](#行锁类型)
- [行锁实现方式](#行锁实现方式)



#### 行锁定义

​		**行级锁：针对数据库表中的行记录加锁，行级锁可以最大程度的支持并发处理，但是同时也带来了最大的锁开销。**

​		行级锁比较容易理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。

​		行级锁是由存储引擎各自实现的，也并不是所有的存储引擎都支持行级锁，比如 MyISAM 引擎就不支持行级锁，这意味着 MyISAM 存储引擎要控制并发只能使用表级锁。

​		**InnoDB 引擎实现了行级锁**，InnoDB 存储引擎中实现了两种标准的行级锁：`共享锁（S锁）`、`排它锁（X锁）`。



#### 支持行锁的存储引擎

​		使用行级锁定的主要有InnoDB存储引擎，以及MySQL的分布式存储引擎NDBCluster



#### 行锁类型

​		InnoDB的行锁分为两种类型：**共享锁**和**排他锁**，而在锁定机制的实现过程中为了让行级锁定和表级锁定**共存**，InnoDB也同样使用了**意向锁（表级锁定）**的概念，也就有了意向共享锁和意向排他锁这两种。

- ##### 共享锁

  - **共享锁（S Lock）**：允许事务读一行

  - **共享锁是兼容锁**，就是当一个事务已经获得了行 r 的共享锁，其他事务可以立即获得行 r 的共享锁，因为读并未改变行 r 的数据。

- ##### 排它锁

  - **排它锁（X Lock）**：允许事务删除和更新一行

  - **排他锁是非兼容锁**，如果有事务想获取行 r 的排他锁，若行 r 上有共享锁或者排它锁，则它必须等其他事务释放行 r 的锁。

> 
>
> 在 InnoDB 存储引擎中，默认情况下使用的是一致性的非锁定行读，也就是通过行多版本控制器来读取行数据，我们可以显示的为行加上共享锁和排它锁，语句如下：
>
> - **SELECT ..... FOR UPDATE**：对读取的行记录加一个排它锁，其他事务想要在这些行上加任何锁都会被阻塞
> - **SELECT ....... LOCK IN SHARE MODE**：对读取的行记录加一个共享锁，其他事务可以向被锁定的记录加共享锁，但是想要加排它锁。则会被阻塞。
>
> 
>
> ​		**一般普通的select语句，InnoDB不加任何锁，我们称之为快照读**
>
> - select * from test;
>
> ​		**通过加S锁和X锁的select语句或者插入/更新/删除操作，我们称之为当前读**
>
> - select * from test lock in share mode;
> - select * from test for update;
> - insert into test values(…);
> - update test set …;
> - delete from test …;
>
> ​		特殊说明：**以上的当前读，读取的都是记录的最新版本。对读取记录都会加锁，除了第一条语句lock in share mode是对记录加S锁（共享锁）外，其他的操作都是加X锁（排他锁）**。
>
> 

​		意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以在需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。

​		意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。所以，可以说InnoDB的`锁定模式实际上可以分为四种`：`共享锁（S）`，`排他锁（X）`，`意向共享锁（IS`）和`意向排他锁（IX）`

​		锁模式的兼容性：

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/17.MySQL-锁-InnoDB锁类型-2.png)





#### 行锁实现方式

​		InnoDB行锁是通过给索引上的`索引项加锁`来实现的。所以，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。其他注意事项：

- 在不通过索引条件查询的时候，InnoDB使用的是表锁，而不是行锁。
- 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以即使是访问不同行的记录，如果使用了相同的索引键，也是会出现锁冲突的。
- 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
- 即便在条件中使用了索引字段，但具体是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。



- **隐式加锁**：

  - InnoDB自动加意向锁。

  - 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加`排他锁（X)`；

  - 对于普通SELECT语句，InnoDB不会加任何锁；


- **显示加锁**：

  - 共享锁（S）：`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`

  - 排他锁（X) ：`SELECT * FROM table_name WHERE ... FOR UPDATE`


​		用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。

​		但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。





#### 参考链接

- [https://blog.csdn.net/zcl_love_wx/article/details/81983267](https://blog.csdn.net/zcl_love_wx/article/details/81983267)

