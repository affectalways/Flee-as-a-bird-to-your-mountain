# 17.行锁

##### 目录

- [行锁定义](#行锁定义)
- [支持行锁的存储引擎](#支持行锁的存储引擎)
- [行锁类型](#行锁类型)
- [行锁实现方式](#行锁实现方式)



![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/%E9%94%81.jpg)





### 行锁定义

**行级锁：针对数据库表中的行记录加锁，行级锁可以最大程度的支持并发处理，但是同时也带来了最大的锁开销。**

行级锁比较容易理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。

行级锁是由存储引擎各自实现的，也并不是所有的存储引擎都支持行级锁，比如 MyISAM 引擎就不支持行级锁，这意味着 MyISAM 存储引擎要控制并发只能使用表级锁。

**InnoDB 引擎实现了行级锁**，InnoDB 存储引擎中实现了两种标准的行级锁：`共享锁（S锁）`、`排它锁（X锁）`。



### 支持行锁的存储引擎

使用行级锁定的主要有InnoDB存储引擎，以及MySQL的分布式存储引擎NDBCluster



### 行锁类型

InnoDB的行锁分为两种类型：**共享锁**和**排他锁**，而在锁定机制的实现过程中为了让`行级锁和表级锁共存`，InnoDB也同样使用了**意向锁（表级锁定）**的概念，也就有了**意向共享锁**和**意向排他锁**这两种。



##### 共享锁

##### 		对于共享锁而言，对当前行加**共享锁**，不会阻塞其他事务对同一行的读请求，但会阻塞对同一行的写请求。只有当读锁释放后，才会执行其它事物的操作。

- **共享锁（S Lock）**：允许事务读一行

- **共享锁是兼容锁**，就是当一个事务已经获得了行 r 的共享锁，其他事务可以立即获得行 r 的共享锁，因为读并未改变行 r 的数据。



##### 排它锁

##### 		对于排它锁而言，会阻塞其他事务对同一行的读和写操作，只有当写锁释放后，才会执行其它事务的读写操作。

- **排它锁（X Lock）**：允许事务删除和更新一行

- **排他锁是非兼容锁**，如果有事务想获取行 r 的排他锁，若行 r 上有共享锁或者排它锁，则它必须等其他事务释放行 r 的锁。

简而言之，就是读锁会阻塞写(X)，但是不会堵塞读(S)。而写锁则会把读(S)和写(X)都堵塞

> 在 InnoDB 存储引擎中，默认情况下使用的快照读（对于普通 select 语句，innodb 不会加任何锁），如果想在select操作的时候加上 S锁 或者 X锁，需要我们手动加锁，语句如下：
>
> - 加共享锁（S）
>
>   **select * from table_name where ... lock in share mode**：对读取的行记录加一个共享锁，其他事务可以向被锁定的记录加共享锁，但是想要加排它锁。则会被阻塞。
>
> - 加排它锁（X)
>
>   **select * from table_name where ... for update**：对读取的行记录加一个排它锁，其他事务想要在这些行上加任何锁都会被阻塞
>
>   对于 update、delete 和 insert 语句， 会自动给涉及数据集加排它锁（X）；



> **一般普通的select语句，InnoDB不加任何锁，我们称之为快照读**
>
> - select * from test;
>
>   
>
> **通过加S锁和X锁的select语句或者插入/更新/删除操作，我们称之为当前读**
>
> - select * from test lock in share mode;
> - select * from test for update;
> - insert into test values(…);
> - update test set …;
> - delete from test …;
>
> 
>
> 特殊说明：**以上的当前读，读取的都是记录的最新版本。对读取记录都会加锁，除了第一条语句lock in share mode是对记录加S锁（共享锁）外，其他的操作都是加X锁（排他锁）**。



##### 意向锁

意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以在需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。

意向锁又分为 意向共享锁（IS）和 意向排他锁（IX）



##### 意向共享(IS)锁

事务有意向对表中的某些行加**共享锁**（S锁）

```
-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 
SELECT column FROM table ... LOCK IN SHARE MODE;
```



##### 意向排他(IX)锁

事务有意向对表中的某些行加**排他锁**（X锁）

```
-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
 SELECT column FROM table ... FOR UPDATE;
```



首先我们要明白四点

- 意向共享锁（IS）和 意向排他锁（IX）都是**表锁**。
- 意向锁是一种 **不与行级锁冲突的表级锁**，这一点非常重要。
- 意向锁是 InnoDB 自动加热， 不需用户干预。
- 意向锁是在 InnoDB 下存在的内部锁，对于MyISAM 而言 没有意向锁之说。

这里就会有疑惑，既然前面已经有了共享锁（S锁）、排它锁（X锁）。那么为什么需要引入意向锁呢？它能解决什么问题呢？

我们可以理解 意向锁 存在的目的就是 为了让 InnoDB 中的行锁和表锁能更高效的共存。

为什么这么说，我们来举一个例子。

举例

下面有一张表 **InnoDB RR隔离级别 id是主键**

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/17.%E6%84%8F%E5%90%91%E9%94%811.jpg)

在讲解插入意向锁之前，先来思考一个问题

```
SELECT * FROM users WHERE id = 6 FOR UPDATE;
```

事务 B 想要获取users表的**表锁**：

```
LOCK TABLES users READ;
```

因为共享锁与排他锁互斥，所以事务 B 在视图对 users 表加共享锁的时候，必须保证：

- 当前没有其他事务持有人 users 表的排他锁。
- 当前没有其他事务持有 users 表中任意一行的排他锁 。

为了检测是否满足第二个条件，事务 B 必须在确保users表不存在任何**排他锁**的前提下，去检测表中的**每一行是否存在排他锁**。很明显这是一个效率很差的做法，但是有了**意向锁**之后，情况就不一样了：事务B只要看表上有没有

意向共享锁，有则说明表中有些行被**共享行锁**锁住了，因此，事务B申请表的写锁会被阻塞。这样是不是就高效多了。

这也解释就应该清楚，为什么有意向锁这个东西存在了。

我们可以举个生活中的例子，再来理解下为什么需要存在意向锁。

打个比方，就像有个游乐场，很多小朋友进去玩，看门大爷如果要下班锁游乐场的门(**加表锁**)，他必须确保每个角落都要去检查一遍，确保每个小朋友都离开了(**释放行锁**)，才可以锁门。

假设锁门是件频繁发生的事情，大爷就会非常崩溃。那大爷想了一个办法，每个小朋友进入，就把自己的名字写在本子上，小朋友离开，就把自己的名字划掉，那大爷就能方便掌握有没有小朋友在游乐场里，不必每个角落都去寻找一遍。

例子中的“小本子”，就是**意向锁**，他记录的信息并不精细，他只是提醒大爷，有人在屋里。

这里我们再来看下 共享(S)锁、排他(X)锁、意向共享锁（IS）、意向排他锁（IX）的兼容性

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/17.%E6%84%8F%E5%90%91%E9%94%812.jpg)



可以看出 **意向锁之间是互相兼容的**。那存在的意义是啥？

意向锁不会为难意向锁。也不会为难行级排他(X)/共享(X)锁，它的存在是为难表级排他(X)/共享(X)锁。

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/17.MySQL-锁-InnoDB锁类型-2.png)

注意**这里的排他(X)/共享(S)锁指的都是表锁！意向锁不会与行级的共享/排他锁互斥！** 行级别的X和S按照上面的兼容性规则即可。

意向锁与意向锁之间永远是兼容的，因为当你不论加行级的X锁或S锁，都会自动获取表级的IX锁或者IS锁。也就是你有10个事务，对不同的10行加了行级X锁，那么这个时候就存在10个IX锁。

这10IX存在的目的是啥呢，就是假如这个时候有个事务，想对整个表加排它X锁,那它不需要遍历每一行是否存在S或X锁，而是看有没有存在意向锁，只要存在一个意向锁，那这个事务就加不了表级排它X锁，要等上面10个IX全部释放才行。





#### 行锁实现方式

​		InnoDB行锁是通过给索引上的`索引项加锁`来实现的。所以，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。其他注意事项：

- 在不通过索引条件查询的时候，InnoDB使用的是表锁，而不是行锁。
- 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以即使是访问不同行的记录，如果使用了相同的索引键，也是会出现锁冲突的。
- 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
- 即便在条件中使用了索引字段，但具体是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。



- **隐式加锁**：

  - InnoDB自动加意向锁。

  - 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加`排他锁（X)`；

  - 对于普通SELECT语句，InnoDB不会加任何锁；


- **显示加锁**：
- 共享锁（S）：`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`
  
- 排他锁（X) ：`SELECT * FROM table_name WHERE ... FOR UPDATE`


​		用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。

​		但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。





#### 参考链接

- [https://blog.csdn.net/zcl_love_wx/article/details/81983267](https://blog.csdn.net/zcl_love_wx/article/details/81983267)
- [https://zhuanlan.zhihu.com/p/436671734](https://zhuanlan.zhihu.com/p/436671734)

