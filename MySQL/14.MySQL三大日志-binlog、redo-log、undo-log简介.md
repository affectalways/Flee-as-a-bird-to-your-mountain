# 14.MySQL三大日志-binlog、redo-log、undo log概览

**目录**

- [简介](#简介)

- [binlog](#binlog)

  - [binlog使用场景](#binlog使用场景)
  - [binlog刷盘时机](#binlog刷盘时机)
  - [binlog日志格式](#binlog日志格式)

- [redo log](#redo-log)

  - [为什么需要redo log](#为什么需要redo-log)
  - [基本概念](#基本概念)
  - [记录形式](#记录形式)
  - [redo log与binlog区别](#redo-log与binlog区别)

- [undo log](#undo-log)

- [参考链接](#参考链接)

  

</br></br>

## 简介

日志是 `mysql `数据库的重要组成部分，记录着数据库运行期间各种状态信息。 
日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。作为开发，我们重点需要关注的是二进制日志( `binlog `)和事务日志(包括
`redo log `和 `undo log `)，本文接下来会详细介绍这三种日志。



</br></br>

## binlog

​		`binlog `用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。 `binlog `是 `mysql`
的逻辑日志，并且由 `Server `层进行记录，使用任何存储引擎的 `mysql `数据库都会记录 `binlog `日志。

- **逻辑日志**： 可以简单理解为记录的就是sql语句 。
- **物理日志**： `mysql `数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。

​		`binlog `是通过追加的方式进行写入的，可以通过 `max_binlog_size `参数设置每个 `binlog`
文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。

</br>

#### binlog使用场景

​		在实际应用中， `binlog `的主要使用场景有两个，分别是 **主从复制** 和 **数据恢复** 。

1. **主从复制** ：在 `Master `端开启 `binlog `，然后将 `binlog `发送到各个 `Slave `端， `Slave `端重放 `binlog `从而达到主从数据一致。
2. **数据恢复** ：通过使用 `mysqlbinlog `工具来恢复数据。

</br>

#### binlog刷盘时机

​		对于 `InnoDB `存储引擎而言，只有在事务提交时才会记录 `biglog `，此时记录还在内存中，那么 `biglog`是什么时候刷到磁盘中的呢？ `mysql `通过 `sync_binlog `参数控制 `biglog `的刷盘时机，取值范围是 `0-N`：

- 0：不去强制要求，由系统自行判断何时写入磁盘；
- 1：每次 `commit `的时候都要将 `binlog `写入磁盘；
- N：每N个事务，才会将 `binlog `写入磁盘。

​		从上面可以看出， `sync_binlog `最安全的是设置是 `1 `，这也是 `MySQL 5.7.7`
之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。

</br>

#### binlog日志格式

​		`binlog `日志有三种格式，分别为 `STATMENT `、 `ROW `和 `MIXED `。

> 在 `MySQL 5.7.7 `之前，默认的格式是 `STATEMENT `， `MySQL 5.7.7 `之后，默认值是 `ROW `。日志格式通过 `binlog-format `指定。

- `STATMENT `： 基于` SQL `语句的复制( `statement-based replication, SBR `)，每一条会修改数据的sql语句会记录到 `binlog `中 。

  ```autohotkey
  * 优点： 不需要记录每一行的变化，减少了` binlog ` 日志量，节约了 ` IO ` , 从而提高了性能； 
  * 缺点： 在某些情况下会导致主从数据不一致，比如执行` sysdate() ` 、 ` slepp() ` 等 。 
  ```

- `ROW `： 基于行的复制(` row-based replication, RBR `)，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了 。

  - 优点： 不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题 ；
  - 缺点： 会产生大量的日志，尤其是` alter table `的时候会让日志暴涨

- `MIXED `： 基于` STATMENT `和 `ROW `两种模式的混合复制( `mixed-based replication, MBR `)，一般的复制使用 `STATEMENT `模式保存 `binlog `，对于 `STATEMENT `模式无法复制的操作使用 `ROW `模式保存 `binlog`



</br></br>

## redo-log

#### 简介

​		`redo log`属于MySQL存储引擎`InnoDB`的事务日志，具体来说就是**只记录事务对数据页做了哪些修改**。

​		我们都知道，事务的四大特性里面有一个是 **持久性** ，具体来说就是**只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态** 。

​		那么 `mysql`是如何保证一致性的呢？最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中，但是这么做会有严重的性能问题：MySQL的数据是存放在磁盘中的，每次读写数据都需做磁盘IO操作，如果并发场景下性能就会很差。为此MySQL提供了一个优化手段，引入缓存`Buffer Pool`。这个缓存中包含了磁盘中**部分**数据页（`page`）的映射，以此来缓解数据库的磁盘压力。

​		当从数据库读数据时，首先从缓存中读取，如果缓存中没有，则从磁盘读取后放入缓存；当向数据库写入数据时，先向缓存写入，此时缓存中的数据页数据变更，这个数据页称为**脏页**，`Buffer Pool`中修改完数据后会按照设定的更新策略，定期刷到磁盘中，这个过程称为**刷脏页**。

</br>

#### 为什么

​		如果刷脏页还未完成，可MySQL由于某些原因宕机重启，此时`Buffer Pool`中修改的数据还没有及时的刷到磁盘中，就会导致数据丢失，无法保证事务的持久性。

​		为了解决这个问题引入了`redo log`，redo Log如其名侧重于重做！它记录的是数据库中每个页的修改，而不是某一行或某几行修改成怎样，可以用来恢复提交后的物理数据页，且只能恢复到最后一次提交的位置。

​		`redo log`用到了`WAL`（Write-Ahead Logging）技术，这个技术的核心就在于修改记录前，一定要先写日志，并保证日志先落盘，才能算事务提交完成。

​		有了redo log再修改数据时，InnoDB引擎会把更新记录先写在redo log中，在修改`Buffer Pool`中的数据，当提交事务时，调用`fsync`把redo log刷入磁盘。至于缓存中更新的数据文件何时刷入磁盘，则由后台线程异步处理。

> **注意**：此时redo log的事务状态是`prepare`，还未真正提交成功，要等`bin log`日志写入磁盘完成才会变更为`commit`，事务才算真正提交完成。

​		这样一来即使刷脏页之前MySQL意外宕机也没关系，只要在重启时解析redo log中的更改记录进行重放，重新刷盘即可。

> **redo log只有InnoDB扫描引擎有哦~**

![](https://raw.githubusercontent.com/affectalways/Flee-as-a-bird-to-your-mountain/main/img/14.MySQL%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%971.jpg)

> 以上是redo log同buffer pool的关系



</br>

#### 基本概念

​		`redo log `包括两部分：一个是内存中的日志缓冲( `redo log buffer `)，另一个是磁盘上的日志文件( ` redo log
file `)。 `mysql `每执行一条 `DML `语句，先将记录写入 `redo log buffer `
，后续某个时间点再一次性将多个操作记录写到 `redo log file `。这种 **先写日志，再写磁盘** 的技术就是 `MySQL`
里经常说到的 `WAL(Write-Ahead Logging) `技术。

​		在计算机操作系统中，用户空间( `user space `)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间( `
kernel space `)缓冲区( `OS Buffer `)。因此， `redo log buffer `写入 `redo log
file `实际上是先写入 `OS Buffer `，然后再通过系统调用 `fsync() `将其刷到 `redo log file `
中，过程如下：

![img](https://segmentfault.com/img/remote/1460000023827701)

​		`mysql `支持三种将 `redo log buffer `写入 `redo log file `的时机，可以通过 `
innodb_flush_log_at_trx_commit ` 参数配置，各参数值含义如下：

| 参数值              | 含义                                                         |
| ------------------- | ------------------------------------------------------------ |
| 0（延迟写）         | 事务提交时不会将 `redo log buffer `中日志写入到 `os buffer `，而是每秒写入 `os buffer `并调用 `fsync() `写入到 `redo log file `中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。 |
| 1（实时写，实时刷） | 事务每次提交都会将 `redo log buffer `中的日志写入 `os buffer `并调用 `fsync() `刷到 `redo log file `中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。 |
| 2（实时写，延迟刷） | 每次提交都仅写入到 `os buffer `，然后是每秒调用 `fsync() `将 `os buffer `中的日志写入到 `redo log file `。 |

![img](https://segmentfault.com/img/remote/1460000023827700)

</br>

#### 记录形式

前面说过， `redo log `实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此 `redo log`
实现上采用了**大小固定，循环写入**的方式，当redo log写满之后，会回到开头循环写日志，如下图：

![img](https://segmentfault.com/img/remote/1460000023827699)

那为什么要如此设计呢？

因为redo log记录的是数据页上的修改，如果`Buffer Pool`中数据页已经刷磁盘后，那这些记录就失效了，新日志会将这些失效的记录进行覆盖擦除。	

同时我们很容易得知， 在innodb中，既有` redo log `需要刷盘，还有 `数据页 `也需要刷盘， `redo log `存在的意义主要就是降低对 `数据页 `刷盘的要求 。

在上图中， write pos 表示 redo log 当前记录的 LSN (逻辑序列号)位置， check point 表示 数据页更改记录刷盘后对应 `redo log `所处的 `LSN `(逻辑序列号)位置。 `write pos `到 `check point `之间的部分是 `redo log `空着的部分，用于记录新的记录；` check point `到 `write pos `之间是 `redo log `待落盘的数据页更改记录。当 `write pos `追上 `check point `时，会先推动 `check point `向前移动，空出位置再记录新的日志。

</br>

#### crash safe

启动 `innodb `的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。因为 `redo log `记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如 `binlog `)要快很多。 重启 `innodb `时，首先会检查磁盘中数据页的 `LSN `，如果数据页的 `LSN `小于日志中的 `LSN `，则会从 `checkpoint `开始恢复。 还有一种情况，在宕机前正处于`checkpoint `的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的 `LSN `大于日志中的 `LSN`，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。

</br>

#### redo-log与binlog区别

|          | redo log                                                     | binlog                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 文件大小 | `redo log `的大小是固定的。                                  | `binlog `可通过配置参数 `max_binlog_size `设置每个` binlog `文件的大小。 |
| 实现方式 | `redo log `是 `InnoDB `引擎层实现的，并不是所有引擎都有。    | `binlog `是 `Server` 层实现的，所有引擎都可以使用 `binlog `日志 |
| 记录方式 | redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。 | binlog通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上 |
| 适用场景 | `redo log `适用于崩溃恢复(crash-safe)                        | `binlog `适用于主从复制和数据恢复                            |

由 `binlog `和 `redo log `的区别可知： `binlog `日志只用于归档，只依靠 `binlog `是没有 `
crash-safe `能力的。但只有 `redo log `也不行，因为 `redo log `是 `InnoDB `
特有的，且日志上的记录落盘后会被覆盖掉。因此需要 `binlog `和 `redo log`
二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。



</br></br>

## undo-log

​		数据库事务四大特性中有一个是  **原子性** 底层就是通过 `undo log `实现的。 

​		`undo log`也是属于MySQL存储引擎InnoDB的事务日志。

​		`undo log`属于逻辑日志，如其名主要起到回滚的作用，它是保证事务原子性的关键。记录的是数据修改前的状态，在数据修改的流程中，同时会记录一条与当前操作相反的逻辑日志到`undo log`中。

​		我们举个栗子：假如更新ID=1记录的name字段，name原始数据为小富，现改name为程序员内点事

​		事务执行`update X set name = 程序员内点事 where id =1`语句时，先会在`undo log`中记录一条相反逻辑的`update X set name = 小富 where id =1`记录，这样当某些原因导致服务异常事务失败，就可以借助`undo log`将数据回滚到事务执行前的状态，保证事务的完整性。

​		那可能有人会问：同一个事物内的一条记录被多次修改，那是不是每次都要把数据修改前的状态都写入`undo log`呢？

​		答案是不会的！

​		`undo log`只负责记录事务开始前要修改数据的原始版本，当我们再次对这行数据进行修改，所产生的修改记录会写入到`redo log`，`undo log`负责完成回滚，`redo log`负责完成前滚。

</br>

#### 回滚

未提交的事务，即事务未执行`commit`。但该事务内修改的脏页中，可能有一部分脏块已经刷盘。如果此时数据库实例宕机重启，就需要用回滚来将先前那部分已经刷盘的脏块从磁盘上撤销。

</br>

#### 前滚

未完全提交的事务，即事务已经执行`commit`，但该事务内修改的脏页中只有一部分数据被刷盘，另外一部分还在`buffer pool`缓存上，如果此时数据库实例宕机重启，就需要用前滚来完成未完全提交的事务。将先前那部分由于宕机在内存上的未来得及刷盘数据，从`redo log`中恢复出来并刷入磁盘。

> 数据库实例恢复时，先做前滚，后做回滚。

如果你仔细看过了上边的 `MySQL数据更新流程图` 就会发现，`undo log`、`redo log`、`bin log`三种日志都是在刷脏页之前就已经刷到磁盘了的，相互协作最大限度保证了用户提交的数据不丢失。

</br>

> `undo log `也是 `MVCC `(多版本并发控制)实现的关键，详情可以参考[5.事务-MVCC](5.事务-MVCC.md)

​	

</br></br>

## 参考链接

- [https://www.cnblogs.com/xuwc/p/13873611.html](https://www.cnblogs.com/xuwc/p/13873611.html)
- [https://www.cnblogs.com/chentianming/p/13494223.html](https://www.cnblogs.com/chentianming/p/13494223.html)
- [https://developer.huawei.com/consumer/cn/forum/topic/0204811671496930254?fid=0101592429757310384](https://developer.huawei.com/consumer/cn/forum/topic/0204811671496930254?fid=0101592429757310384)
- [https://www.cnblogs.com/semi-sub/p/14225047.html](https://www.cnblogs.com/semi-sub/p/14225047.html)
- [https://www.modb.pro/db/61901](https://www.modb.pro/db/61901)