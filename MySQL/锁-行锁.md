# 锁-行锁

​		MySQL 的行锁是在引擎层由各个**引擎实现**的。

​		并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。

​		我们今天就主要来聊聊 InnoDB 的行锁，以及如何通过减少锁冲突来提升业务并发度。

​		顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。

​		当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如两阶段锁。





## 两阶段锁协议

​		先举个例子。在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。

![]()

​		这个问题取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放。

​		`事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。`

​		事务 A 持有的两个记录的行锁，都是在 commit 的时候才释放的。

​		也就是说，**在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**

​		知道了这个设定，对我们使用事务有什么帮助呢？那就是，**如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。**

​		举个例子：

​		假设负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票，顾客C要在影院B购买电影票。简化一点，这个业务需要涉及到以下操作：

​		1.从顾客 A 账户余额中扣除电影票价；

​		2.给影院 B 的账户余额增加这张电影票价；

​		3.从顾客 C 账户余额中扣除电影票价；