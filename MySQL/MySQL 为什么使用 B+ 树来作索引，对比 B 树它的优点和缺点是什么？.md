### MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？

首先需要澄清的一点是，MySQL跟B+树没有直接的关系，真正与B+树有关系的是MySQL的默认存储引擎`InnoDB`，MySQL中存储引擎的主要作用是`负责数据的存储和提取`，除了`InnoDB`之外，MySQL中也支持比如`MyISAM`等其他存储引擎(详情见`https://dev.mysql.com/doc/refman/5.7/en/storage-engine-setting.html`)作为表的底层存储引擎。

```
mysql> show engines;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
```

提到索引，我们可能会立马想到下面几种数据结构来实现。

(1) 哈希表 哈希虽然能够提供`O(1)`的单数据行的查询性能，但是对于`范围查询`和`排序`却无法很好支持，需全表扫描。

(2) 红黑树 红黑树(`Red Black Tree`)是一种自平衡二叉查找树，在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。

一般来说，索引本身也很大，往往不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗远远高于内存，所以评价一个数据结构作为索引的优劣最重要的指标就是查找过程中磁盘I/O次数。换句话说，`索引的结构组织要尽量减少查找过程中磁盘I/O的次数。`

在这里，磁盘I/O的次数取决于树的高度，所以，在数据量较大时，`红黑树会因树的高度较大而造成磁盘IO较多`，从而影响查询效率。

(3) B-Tree B树中的B代表平衡(`Balance`)，而不是二叉(`Binary`)，B树是从平衡二叉树演化而来的。

为了降低树的高度(也就是减少磁盘I/O次数)，把原来`瘦高`的树结构变得`矮胖`，B树会在`每个节点存储多个元素`(红黑树每个节点只会存储一个元素)，并且节点中的元素从左到右递增排列。如下图所示：

[![B-Tree结构图](https://camo.githubusercontent.com/819538d991f9db08fb244b7b0a213c01b66c29102373cccf7da20eefd47d67ff/68747470733a2f2f696d67323032302e636e626c6f67732e636f6d2f626c6f672f313534363633322f3230323030382f313534363633322d32303230303833303139353334383336382d313330343037383235382e706e67)](https://img2020.cnblogs.com/blog/1546632/202008/1546632-20200830195348368-1304078258.png)

`B-Tree`在查询的时候比较次数其实不比二叉查找树少，但在内存中的大小比较、二分查找的耗时相比磁盘IO耗时几乎可以忽略。 `B-Tree大大降低了树的高度`，所以也就极大地提升了查找性能。

(4) B+Tree `B+Tree`是在`B-Tree`基础上进一步优化，使其更适合实现存储索引结构。InnoDB存储引擎就是用`B+Tree`实现其索引结构。

`B-Tree`结构图中可以看到每个节点中不仅包含数据的`key`值，还有`data`值。而每一个节点的存储空间是有限的，如果`data`值较大时将会导致每个节点能存储的`key`的数量很小，这样会导致B-Tree的高度变大，增加了查询时的磁盘I/O次数，进而影响查询性能。在`B+Tree`中，所有`data`值都是按照键值大小顺序存放在同一层的叶子节点上，而`非叶子节点上只存储key值信息`，这样可以增大每个非叶子节点存储的`key`值数量，降低B+Tree的高度，提高效率。

[![B+Tree结构图](https://camo.githubusercontent.com/792f541f0559575c37b985671caac3c15b187f63de6df1fbe97c0b0d1272c077/68747470733a2f2f696d67323032302e636e626c6f67732e636f6d2f626c6f672f313534363633322f3230323030382f313534363633322d32303230303833303230313431333133342d3339343831363037332e706e67)](https://img2020.cnblogs.com/blog/1546632/202008/1546632-20200830201413134-394816073.png)

**这里补充一点相关知识** 在计算机中，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的`局部性原理`：

> 当一个数据被用到时，其附近的数据也通常会马上被使用。

由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为页(`page`)的整数倍。

`页`是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页(许多操作系统的页默认大小为`4KB`)，主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时操作系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。(如下命令可以查看操作系统的默认页大小)

```
$ getconf PAGE_SIZE
4096
```

数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为操作系统的页大小的整数倍，这样每个节点只需要一次I/O就可以完全载入。

`InnoDB`存储引擎中也有页(`Page`)的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB。

```
mysql> show variables like 'innodb_page_size';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| innodb_page_size | 16384 |
+------------------+-------+
1 row in set (0.01 sec)
```

一般表的主键类型为`INT`（占4个字节）或`BIGINT`（占8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储`16KB/(8B+8B)=1K`个键值（因为是估值，为方便计算，这里的K取值为`10^3`）。也就是说一个深度为3的B+Tree索引可以维护`10^3 * 10^3 * 10^3 = 10亿`条记录。

`B+Tree`的高度一般都在2到4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1到3次磁盘I/O操作。

随机I/O对于MySQL的查询性能影响会非常大，而顺序读取磁盘中的数据会很快，由此我们也应该尽量减少随机I/O的次数，这样才能提高性能。在`B-Tree`中由于所有的节点都可能包含目标数据，我们总是要从根节点向下遍历子树查找满足条件的数据行，这会带来大量的随机I/O，而`B+Tree`所有的数据行都存储在叶子节点中，而这些叶子节点通过`双向链表`依次按顺序连接，当我们在B+树遍历数据(比如说`范围查询`)时可以直接在多个叶子节点之间进行跳转，保证`顺序`、`倒序`遍历的性能。

另外，对以上提到的数据结构不熟悉的朋友，这里推荐一个在线数据结构可视化演示工具，有助于快速理解这些数据结构的机制：`https://www.cs.usfca.edu/~galles/visualization/Algorithms.html`
