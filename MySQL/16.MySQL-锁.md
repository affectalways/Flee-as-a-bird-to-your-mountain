# 16.MySQL-锁

**目录**

- [是什么](#是什么)
- [全局锁](#全局锁)
- [表级锁](#表级锁)
  - [元数据锁MDL](#元数据锁MDL)
- [行锁](#行锁)
  - [共享锁](#共享锁)
  - [排它锁](#排它锁)
- [参考链接](#参考链接)

</br></br>

#### 是什么

​		程序在高并发的情况下，通常都会通过加锁的方式来保证数据一致性、安全性。

​		在 MySQL 数据库中同样存在这样的困扰：为了最大程度的并发访问数据库，又需要保证每个用户能正常读取、修改数据。所以MySQL引入了锁机制。

​		在 MySQL 数据库中，锁有很多种类型，**根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类**。



</br></br>

#### 全局锁

​		**全局锁**是粒度最大的锁，**控制整个数据库实例**。

​		**全局锁就是对整个数据库实例加锁，让整个数据库处于只读状态。**

​		MySQL 提供了一个加全局读锁的方法，命令是 **Flush tables with read lock**，加锁之后整个数据库实例处于只读状态，有关数据操作的命令都会被挂起阻塞，例如数据更新语句、数据定义语句、更新类事务语句等等。

​		所以**全局锁一般只用于全库备份的时候，一般只用在不支持一致性读的存储引擎做全库备份时**，比如 MyISAM 这种不支持一致性读的存储引擎做全库备份时需要使用全局锁，像 InnoDB 引擎做全库备份时不需要使用全局锁。



</br></br>

#### 表级锁

​		**表级锁是 MySQL 最基本的锁策略，并且是开销最小的策略，它锁住的不是整个数据库实例，而是一张表。**

​		表级锁跟全局锁一样，MySQL 数据库提供了加锁的命令： **lock tables … read/write**。

​		例如 `线程A`执行`lock tables t1 read, t2 write;` 命令，**其他线程写 t1、读写 t2 的语句都会被阻塞**。同时，`线程 A` 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作, 连写 t1 都不允许，

​		我们可以**使用 unlock tables 主动释放锁，如果没有使用的话，在客户端断开的时候自动释放**。

​	</br>

- ##### 元数据锁MDL

> 元数据锁MDL是server层的锁，表级锁


​		表级锁存在一个问题，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

​		为了解决这个问题，**MySQL 5.5版本之后引入了元数据锁（meta data lock，MDL)。**

​		**MDL 是数据库自动加锁，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁**。

MDL 锁有以下两个特点：

- **读锁之间不互斥**，因此你可以有多个线程同时对一张表增删改查。
- **读写锁之间、写锁之间是互斥的**，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，**其中一个要等另一个执行完才能开始执行**。

</br>

##### InnoDB如何加表锁：

  在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。

```
SET AUTOCOMMIT=0;
LOCK TABLES t1 WRITE, t2 READ, ...;
[do something with tables t1 and t2 here];
COMMIT;
UNLOCK TABLES;
```

</br></br>

#### 行级锁

[17.行锁.md](17.行锁.md)



</br></br>

#### 参考链接

- [https://www.cnblogs.com/jamaler/p/12249007.html](https://www.cnblogs.com/jamaler/p/12249007.html)