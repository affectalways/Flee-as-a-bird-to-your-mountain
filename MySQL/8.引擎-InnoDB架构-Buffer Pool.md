# 8.引擎-InnoDB架构-Buffer Pool

​		InnoDB是基于**磁盘**存储的，并将其中的数据按**页的方式**进行管理。但是如果MySQL的操作都在磁盘中进行，每次都要从磁盘中拿数据，需要IO，并且数据库还不知道他要找的数据在磁盘的哪个位置，所以就需要进行随机IO，性能极差。所以需要**缓冲池Buffer Pool**来提高数据库的整体性能。

> MySQL的数据最终保存在磁盘上，保持了数据的持久性。
>
> 在磁盘上对数据进行DML操作，速度是非常慢的（磁盘的随机读写非常消耗性能），比如一个大的磁盘文件进行DML操作，可能要几百毫秒，也会造成性能低、响应慢等问题；而如果在内存上对数据进行DML的话，速度就可以快了很多；所以，InnoDB的Buffer Pool出来了，在对数据库做DML操作的时候，不对磁盘进行DML操作,而是对缓冲池(Buffer Pool)里的数据进行DML操作

​	

​		**缓冲池Buffer Pool**是内存中的一个区域，用于在 **InnoDB**访问表和索引数据时对其进行缓存。**缓冲池Buffer Pool**允许直接从内存中访问经常使用的数据，从而加快处理速度。

​		 为了提高大容量读操作的效率，缓冲池被分割成一个个可以**容纳多行的页(pages)**。

​		为了方便缓存管理，缓冲池被实现成页的**链表结构**；很少使用的数据会使用 LRU 算法的一种变体从缓存中淘汰。

[MySQL官方网站](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html)



### Buffer Pool的工作流程

![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/8.%E5%BC%95%E6%93%8E-InnoDB%E6%9E%B6%E6%9E%84-Buffer%20Pool.png?raw=true)

以查询语句为例

1. 在查询的时候会先去buffer pool(内存)中看看有没有对应的数据页，如果有的话直接返回
2. 如果buffer pool中没有对应的数据页，则会去磁盘中查找，磁盘中如果找到了对应的数据，则会把该页的数据直接copy一份到buffer pool中返回给客户端
3. 下次有同样的查询进来直接查找buffer pool找到对应的数据返回即可。





### Buffer Pool内存数据结构

#### 1.数据页

是 MySQL 抽象出来的数据单位，磁盘文件中就是存放了很多数据页，每个数据页里存放了很多行数据。

默认情况下，数据页的大小是 16kb。

对应的，在 `Buffer Pool` 中，也是以数据页为数据单位，存放着很多数据。但是我们通常叫做缓存页，因为 `Buffer Pool` 毕竟是一个缓冲池，并且里面的数据都是从磁盘文件中缓存到内存中。

所以，默认情况下缓存页的大小也是 16kb，因为它和磁盘文件中数据页是一一对应的。

所以，缓冲池和磁盘之间的数据交换的单位是数据页，Buffer Pool中存放的是一个一个的数据页。

假设我们要更新一行数据，此时数据库会找到这行数据所在的数据页，然后从磁盘文件里把这行数据所在的数据页直接给加载到Buffer Pool里去。如下图。

![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/8.%E5%BC%95%E6%93%8E-InnoDB%E6%9E%B6%E6%9E%84-Buffer%20Pool-%E6%95%B0%E6%8D%AE%E9%A1%B5.png?raw=true)



#### 2.怎么识别数据在哪个缓存页中

每个缓存页都会对应着一个描述数据块，里面包含数据页所属的表空间、数据页的编号，缓存页在 `Buffer Pool` 中的地址等等。

描述数据块本身也是一块数据，它的大小大概是缓存页大小的5%左右，大概800个字节左右的大小。然后假设你设置的buffer pool大小是128MB，实际上Buffer Pool真正的最终大小会超出一些，可能有个130多MB的样子，因为他里面还要存放每个缓存页的描述数据。

在Buffer Pool中，每个缓存页的描述数据放在最前面，然后各个缓存页放在后面。所以此时我们看下面的图，Buffer Pool实际看起来大概长这个样子 。



### Buffer Pool的初始化

MySQL 启动时，是如何初始化 `Buffer Pool` 的呢？

1、MySQL 启动时，会根据参数 `innodb_buffer_pool_size` 的值来为 `Buffer Pool` 分配内存区域。

2、然后会按照缓存页的默认大小 16k 以及对应的描述数据块的 800个字节 左右大小，在 `Buffer Pool` 中划分中一个个的缓存页和一个个的描述数据库块。

3、注意，此时的缓存页和描述数据块都是空的，毕竟才刚启动 MySQL 呢。



### Buffer Pool的配置（可忽略，实际操作才会用到）

​		Buffer Pool通常由数个内存块加上一组控制结构体对象组成。内存块的个数取决于buffer pool instance的个数。

​		Buffer Pool默认情况下是128MB，还是有一点偏小了，我们实际生产环境下完全可以对Buffer Pool进行调整。 比如我们的数据库如果是16核32G的机器，那么你就可以给Buffer Pool分配个2GB的内存。

```
1.innodb_buffer_pool_size：这个值是设置 InnoDB Buffer Pool 的总大小；
2.innodb_buffer_pool_chunk_size：当增加或减少innodb_buffer_pool_size时，操作以块（chunk）形式执行。块大小由innodb_buffer_pool_chunk_size配置选项定义，默认值128M。
3.innodb_buffer_pool_instances：设置 InnoDB Buffer Pool 实例的个数，每一个实例都有自己独立的 list 管理Buffer Pool；
4.innodb_old_blocks_pct：默认 InnoDB Buffer Pool 中点的位置，默认值是37，最大100，也就是我们所谓的3/8的位置，可以自己设置。
```

> ​	当buffer pool比较大的时候（超过1G），innodb会把buffer pool划分成几个instances，这样可以提高读写操作的并发，减少竞争。读写page都使用hash函数分配给一个instances。
>
> ​	这里面有个关系要确定一下，最好按照这个设置 innodb_buffer_pool_size=innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances*N（N>=1）
>
> ​	buffer pool的大小必须是innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances的整数倍，如果配置的innodb_buffer_pool_size不是innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances的倍数，buffer pool的大小会自动调整为innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances的倍数，自动调整的值不少于指定的值。
>
> ​	如果指定的buffer大小是9G，instances的个数是16，chunk默认的大小是128M，那么buffer会自动调整为10G。







### 疑问

> 既然DML是对缓存池执行，那么缓存池的数据更新了，但还没有同步到磁盘，但是这时数据库突然宕机了，那么内存中更新的数据不就都没了？

针对这个问题，mysql引入了**日志机制（redo log）**,当对缓冲池里面的数据进行DML的时候，mysql会把DML的记录写入日志文件中（redo log之后会有详解），万一数据库突然宕机，只要从redo log日志里面读取之前的做过的DML操作，瞬间就可以重新把这些DML操作在内存执行一遍，这样就可以恢复之前做过的DML操作。当然对数据更新的过程，MySQL是有一套严密的步骤，还涉及到undo log、binlog、事务、buffer pool脏数据处理等等。