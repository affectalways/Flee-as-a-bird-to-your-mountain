# 8.引擎-InnoDB架构-Buffer Pool

​		InnoDB是基于**磁盘**存储的，并将其中的数据按**页的方式**进行管理。但是如果MySQL的操作都在磁盘中进行，每次都要从磁盘中拿数据，需要IO，并且数据库还不知道他要找的数据在磁盘的哪个位置，所以就需要进行随机IO，性能极差。所以需要**缓冲池Buffer Pool**来提高数据库的整体性能。

> MySQL的数据最终保存在磁盘上，保持了数据的持久性。
>
> 在磁盘上对数据进行DML操作，速度是非常慢的（磁盘的随机读写非常消耗性能），比如一个大的磁盘文件进行DML操作，可能要几百毫秒，也会造成性能低、响应慢等问题；而如果在内存上对数据进行DML的话，速度就可以快了很多；所以，InnoDB的Buffer Pool出来了，在对数据库做DML操作的时候，不对磁盘进行DML操作,而是对缓冲池(Buffer Pool)里的数据进行DML操作

​	

​		**缓冲池Buffer Pool**是内存中的一个区域，用于在 **InnoDB**访问表和索引数据时对其进行缓存。**缓冲池Buffer Pool**允许直接从内存中访问经常使用的数据，从而加快处理速度。

​		 为了提高大容量读操作的效率，缓冲池被分割成一个个可以**容纳多行的页(pages)**。

​		为了方便缓存管理，缓冲池被实现成页的**链表结构**；很少使用的数据会使用 LRU 算法的一种变体从缓存中淘汰。

[MySQL官方网站](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html)



### Buffer Pool的工作流程

![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/8.%E5%BC%95%E6%93%8E-InnoDB%E6%9E%B6%E6%9E%84-Buffer%20Pool.png?raw=true)

以查询语句为例

1. 在查询的时候会先去buffer pool(内存)中看看有没有对应的数据页，如果有的话直接返回
2. 如果buffer pool中没有对应的数据页，则会去磁盘中查找，磁盘中如果找到了对应的数据，则会把该页的数据直接copy一份到buffer pool中返回给客户端
3. 下次有同样的查询进来直接查找buffer pool找到对应的数据返回即可。





### Buffer Pool内存数据结构

- #### 数据页

是 MySQL 抽象出来的数据单位，磁盘文件中就是存放了很多数据页，每个数据页里存放了很多行数据。

默认情况下，数据页的大小是 16kb。

对应的，在 `Buffer Pool` 中，也是以数据页为数据单位，存放着很多数据。但是我们通常叫做缓存页，因为 `Buffer Pool` 毕竟是一个缓冲池，并且里面的数据都是从磁盘文件中缓存到内存中。

所以，默认情况下缓存页的大小也是 16kb，因为它和磁盘文件中数据页是一一对应的。

所以，缓冲池和磁盘之间的数据交换的单位是数据页，Buffer Pool中存放的是一个一个的数据页。

假设我们要更新一行数据，此时数据库会找到这行数据所在的数据页，然后从磁盘文件里把这行数据所在的数据页直接给加载到Buffer Pool里去。如下图。



- 



### 疑问

> 既然DML是对缓存池执行，那么缓存池的数据更新了，但还没有同步到磁盘，但是这时数据库突然宕机了，那么内存中更新的数据不就都没了？

针对这个问题，mysql引入了**日志机制（redo log）**,当对缓冲池里面的数据进行DML的时候，mysql会把DML的记录写入日志文件中（redo log之后会有详解），万一数据库突然宕机，只要从redo log日志里面读取之前的做过的DML操作，瞬间就可以重新把这些DML操作在内存执行一遍，这样就可以恢复之前做过的DML操作。当然对数据更新的过程，MySQL是有一套严密的步骤，还涉及到undo log、binlog、事务、buffer pool脏数据处理等等。