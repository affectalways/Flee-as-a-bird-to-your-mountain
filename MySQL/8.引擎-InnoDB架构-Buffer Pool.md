# 8.引擎-InnoDB架构-Buffer Pool

### 前言

![](https://dev.mysql.com/doc/refman/5.7/en/images/innodb-architecture.png)



### 是什么

​		**缓冲池Buffer Pool**是内存中的一个区域，用于在 **InnoDB**访问表和索引数据时对其进行缓存。**缓冲池Buffer Pool**允许直接从内存中访问经常使用的数据，从而加快处理速度。

​		 为了提高大容量读操作的效率，缓冲池被分割成一个个可以**容纳多行的页(pages)**。

​		为了方便缓存管理，缓冲池被实现成页的**链表结构**；很少使用的数据会使用 LRU 算法的一种变体从缓存中淘汰。

[MySQL官方网站](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html)



### 为什么

​		InnoDB是基于**磁盘**存储的，并将其中的数据按**页的方式**进行管理。但是如果MySQL的所有操作都在磁盘中进行，每次都要从磁盘中拿数据，需要IO，并且数据库还不知道他要找的数据在磁盘的哪个位置，所以就需要进行随机IO，性能极差。所以需要**缓冲池Buffer Pool**来提高数据库的整体性能。

> MySQL的数据最终保存在磁盘上，保持了数据的持久性。
>
> 在磁盘上对数据进行DML操作，速度是非常慢的（磁盘的随机读写非常消耗性能），比如一个大的磁盘文件进行DML操作，可能要几百毫秒，也会造成性能低、响应慢等问题；而如果在内存上对数据进行DML的话，速度就可以快了很多；所以，InnoDB的Buffer Pool出来了，在对数据库做DML操作的时候，不对磁盘进行DML操作,而是对缓冲池(Buffer Pool)里的数据进行DML操作

​	

### Buffer Pool的工作流程

![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/8.%E5%BC%95%E6%93%8E-InnoDB%E6%9E%B6%E6%9E%84-Buffer%20Pool.png?raw=true)

以查询语句为例

1. 在查询的时候会先去buffer pool(内存)中看看有没有对应的数据页，如果有的话直接返回
2. 如果buffer pool中没有对应的数据页，则会去磁盘中查找，磁盘中如果找到了对应的数据，则会把该页的数据直接copy一份到buffer pool中返回给客户端
3. 下次有同样的查询进来直接查找buffer pool找到对应的数据返回即可。



### Buffer Pool内存数据结构

#### 1.缓存页

是 MySQL 抽象出来的数据单位，磁盘文件中就是存放了很多数据页，每个数据页里存放了很多行数据。

默认情况下，数据页的大小是 16kb。

对应的，在 `Buffer Pool` 中，也是以数据页为数据单位，存放着很多数据。但是我们通常叫做**缓存页**，因为 `Buffer Pool` 毕竟是一个缓冲池，并且里面的数据都是从磁盘文件中缓存到内存中。

所以，默认情况下缓存页的大小也是 16kb，因为它和磁盘文件中数据页是一一对应的。

所以，缓冲池和磁盘之间的数据交换的单位是数据页，Buffer Pool中存放的是一个一个的数据页。

假设我们要更新一行数据，此时数据库会找到这行数据所在的数据页，然后从磁盘文件里把这行数据所在的数据页直接给加载到Buffer Pool里去。如下图：

![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/8.%E5%BC%95%E6%93%8E-InnoDB%E6%9E%B6%E6%9E%84-Buffer%20Pool-%E6%95%B0%E6%8D%AE%E9%A1%B5.png?raw=true)



#### 2.怎么识别数据在哪个缓存页中

https://blog.csdn.net/zhizhengguan/article/details/121996679

每个**缓存页**都会对应着**一个描述数据块**，里面包含 缓存页所属的表空间、缓存页的编号，缓存页在 `Buffer Pool` 中的地址等等。

**描述数据块**本身也是一块数据，它的大小大概是缓存页大小的5%左右，大概800个字节左右的大小。然后假设你设置的buffer pool大小是128MB，实际上Buffer Pool真正的最终大小会超出一些，可能有个130多MB的样子，因为他里面还要存放每个缓存页的描述数据。

在Buffer Pool中，每个缓存页的描述数据放在最前面，然后各个缓存页放在后面。所以此时我们看下面的图，Buffer Pool实际看起来大概长这个样子 。

![Buffer Pool长什么样子](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/8.%E5%BC%95%E6%93%8E-InnoDB%E6%9E%B6%E6%9E%84-Buffer%20Pool-%E9%95%BF%E7%9B%B8.png?raw=true)



### Buffer Pool的初始化与配置（可忽略，实际操作才会用到）

#### Buffer Pool的初始化

MySQL 启动时，是如何初始化 `Buffer Pool` 的呢？

1、MySQL 启动时，会根据参数 `innodb_buffer_pool_size` 的值来为 `Buffer Pool` 分配内存区域。

2、然后会按照缓存页的默认大小 16k 以及对应的描述数据块的 800个字节 左右大小，在 `Buffer Pool` 中划分中一个个的缓存页和一个个的描述数据库块。

3、注意，此时的缓存页和描述数据块都是空的，毕竟才刚启动 MySQL 呢。

#### Buffer Pool的配置

​		Buffer Pool通常由数个内存块加上一组控制结构体对象组成。内存块的个数取决于buffer pool instance的个数。

​		Buffer Pool默认情况下是128MB，还是有一点偏小了，我们实际生产环境下完全可以对Buffer Pool进行调整。 比如我们的数据库如果是16核32G的机器，那么你就可以给Buffer Pool分配个2GB的内存。

```
1.innodb_buffer_pool_size：这个值是设置 InnoDB Buffer Pool 的总大小；
2.innodb_buffer_pool_chunk_size：当增加或减少innodb_buffer_pool_size时，操作以块（chunk）形式执行。块大小由innodb_buffer_pool_chunk_size配置选项定义，默认值128M。
3.innodb_buffer_pool_instances：设置 InnoDB Buffer Pool 实例的个数，每一个实例都有自己独立的 list 管理Buffer Pool；
4.innodb_old_blocks_pct：默认 InnoDB Buffer Pool 中点的位置，默认值是37，最大100，也就是我们所谓的3/8的位置，可以自己设置。
```

> ​	当buffer pool比较大的时候（超过1G），innodb会把buffer pool划分成几个instances，这样可以提高读写操作的并发，减少竞争。读写page都使用hash函数分配给一个instances。
>
> ​	这里面有个关系要确定一下，最好按照这个设置 innodb_buffer_pool_size=innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances*N（N>=1）
>
> ​	buffer pool的大小必须是innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances的整数倍，如果配置的innodb_buffer_pool_size不是innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances的倍数，buffer pool的大小会自动调整为innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances的倍数，自动调整的值不少于指定的值。
>
> ​	如果指定的buffer大小是9G，instances的个数是16，chunk默认的大小是128M，那么buffer会自动调整为10G。



#### （1）Buffer Pool Size设置和生效过程

​		理想情况下，在给服务器的其他进程留下足够的内存空间的情况下，Buffer Pool Size 应该设置的尽可能大。当 Buffer Pool Size 设置的足够大时，整个数据库就相当于存储在内存当中，当读取一次数据到 Buffer Pool Size 以后，后续的读操作就不用再访问磁盘。

下面我们看一下 Buffer Pool Size 的设置方式：

当数据库已经启动的情况下，可以通过通过以下语句调整Buffer Pool Size大小：

```
SET GLOBAL innodb_buffer_pool_size=402653184;
```

当执行这个语句以后，并不会立即生效，而是要等所有的事务全部执行成功以后才会生效；新的连接和事务必须等其他事务完全执行成功以后，Buffer Pool Size 设置生效以后才能够连接成功，不然会一直处于等待状态。

期间，Buffer Pool Size 要完成碎片整理，去除缓存 page 等等操作。在执行增加或者减少 Buffer Pool Size 的操作时，操作会作为一个执行块执行，innodb_buffer_pool_chunk_size 的大小会定义一个执行块的大小，默认的情况下，这个值是128M。

Buffer Pool Size 的大小最好设置为 innodb_buffer_pool_chunk_size、innodb_buffer_pool_instances 的**整数倍**，而且是大于等于1。

如果你的机器配置的大小**不是整数倍**的话，Buffer Pool Size 的大小是会自适应修改为 innodb_buffer_pool_chunk_size、innodb_buffer_pool_instances 的整数倍，会略小于你配置的 Buffer Pool Size 的大小。

#### （2）Buffer Pool Instances

争用。**下面我们看一下怎么配置 Buffer Pool Instances？**

配置多个 Buffer Pool Instances 能在很大程度上能够提高 MySQL 在高并发的情况下处理事物的性能，优化不同连接读取缓冲页的争用。

**我们可以通过设置 innodb_buffer_pool_instances 来设置 Buffer Pool Instances**。当 InnoDB Buffer Pool 足够大的时候，你能够从内存中读取时候能有一个较好的性能，但是也有可能碰到多个线程同时请求缓冲池的瓶颈。这个时候设置多个 Buffer Pool Instances 能够尽量减少连接的争用。

这能够保证每次从内存读取的页都对应一个 Buffer Pool Instances，而且这种对应关系是一个随机的关系。并不是热数据存放在一个 Buffer Pool Instances下，内部也是通过 hash 算法来实现这个随机数的。每一个 Buffer Pool Instances 都有自己的 free lists，LRU 和其他的一些 Buffer Poll 的数据结构，各个 Buffer Pool Instances 是相对独立的。

innodb_buffer_pool_instances 的设置必须大于1才算得上是多配置，**但是这个功能起作用的前提**是innodb_buffer_pool_size 的大小必须大于1G，理想情况下 innodb_buffer_pool_instances 的每一个 instance 都保证在1G以上。

#### （3）SHOW ENGINE INNODB STATUS

当你的数据库启动之后，你随时可以通过上述命令，去查看当前innodb里的一些具体情况，执行SHOW ENGINE INNODB STATUS就可以了。此时你可能会看到如下一系列的东西：

```
Total memory allocated xxxx;
Dictionary memory allocated xxx
Buffer pool size xxxx
Free buffers xxx
Database pages xxx
Old database pages xxxx
Modified db pages xx
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young xxxx, not young xxx
xx youngs/s, xx non-youngs/s
Pages read xxxx, created xxx, written xxx
xx reads/s, xx creates/s, 1xx writes/s
Buffer pool hit rate xxx / 1000, young-making rate xxx / 1000 not xx / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: xxxx, unzip_LRU len: xxx
I/O sum[xxx]:cur[xx], unzip sum[16xx:cur[0]
```

下面解释一下这里的东西，主要讲解这里跟buffer pool相关的一些东西。

> 1. Total memory allocated，这就是说buffer pool最终的总大小是多少
> 2. Buffer pool size，这就是说buffer pool一共能容纳多少个缓存页
> 3. Free buffers，这就是说free链表中一共有多少个空闲的缓存页是可用的
> 4. Database pages和Old database pages，就是说lru链表中一共有多少个缓存页，以及冷数据区域里的缓存页数量
> 5. Modified db pages，这就是flush链表中的缓存页数量
> 6. Pending reads和Pending writes，等待从磁盘上加载进缓存页的数量，还有就是即将从lru链表中刷入磁盘的数量、即将从flush链表中刷入磁盘的数量
> 7. Pages made young和not young，这就是说已经lru冷数据区域里访问之后转移到热数据区域的缓存页的数 量，以及在lru冷数据区域里1s内被访问了没进入热数据区域的缓存页的数量
> 8. youngs/s和not youngs/s，这就是说每秒从冷数据区域进入热数据区域的缓存页的数量，以及每秒在冷数据区域里被访问了但是不能进入热数据区域的缓存页的数量
> 9. Pages read xxxx, created xxx, written xxx，xx reads/s, xx creates/s, 1xx writes/s，这里就是说已经读取、创建和写入了多少个缓存页，以及每秒钟读取、创建和写入的缓存页数量
> 10. Buffer pool hit rate xxx / 1000，这就是说每1000次访问，有多少次是直接命中了buffer pool里的缓存的
> 11. young-making rate xxx / 1000 not xx / 1000，每1000次访问，有多少次访问让缓存页从冷数据区域移动到了热数据区域，以及没移动的缓存页数量
> 12. LRU len：这就是lru链表里的缓存页的数量
> 13. I/O sum：最近50s读取磁盘页的总数
> 14. I/O cur：现在正在读取磁盘页的数量



### Buffer Pool 空间管理

​		缓冲池也是有大小限制的，那么既然缓冲池有大小限制的，每次都读入的数据页怎么来管理呢？这里我们来聊聊缓冲池的空间管理，其实对缓冲池进行管理的关键部分是如何安排进池的数据并且按照一定的策略淘汰池中的数据，保证池中的数据不“溢出”，同时还能保证常用数据留在池子中。

![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/8.%E5%BC%95%E6%93%8E-InnoDB%E6%9E%B6%E6%9E%84-Buffer%20Pool-%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86.png?raw=true)

- #### 传统LRU淘汰法

  缓冲池是基于传统的 LRU 方法来进行缓存页管理的

  LRU，全称是 Least Recently Used，中文名字叫作「最近最少使用」。这里分两种情况：

  - ##### 缓存页已在缓冲池中

  这种情况下会将对应的缓存页放到 LRU 链表的头部，无需从磁盘再进行读取，也无需淘汰其它缓存页。

  如下图所示，如果要访问的数据在 6 号页中，则将 6 号页放到链表头部即可，这种情况下没有缓存页被淘汰。

  ![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/8.%E5%BC%95%E6%93%8E-InnoDB%E6%9E%B6%E6%9E%84-Buffer%20Pool-%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86-LRU%E5%B7%B2%E5%AD%98%E5%9C%A8.png?raw=true)

  - ##### 缓存页不在缓冲池中

  缓存页不在缓冲中，这时候就需要从磁盘中读入对应的数据页，将其放置在链表头部，同时淘汰掉末尾的缓存页 

  如下图所示，如果要访问的数据在 60 号页中，60 号页不在缓冲池中，此时加载进来放到链表的头部，同时淘汰掉末尾的 17 号缓存页。

  ![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/8.%E5%BC%95%E6%93%8E-InnoDB%E6%9E%B6%E6%9E%84-Buffer%20Pool-%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86-LRU%E4%B8%8D%E5%AD%98%E5%9C%A8.png?raw=true)

> 是不是看上去很简单，同时也能满足缓冲池淘汰缓存页的方法？但是我们来思考几个问题：
>
> **预读失效**
>
> 　　上面我们提到了缓冲池的预读机制可能会预先加载相邻的数据页。假如加载了 20、21 相邻的两个数据页，如果只有页号为 20 的缓存页被访问了，而另一个缓存页却没有被访问。此时两个缓存页都在链表的头部，但是为了加载这两个缓存页却淘汰了末尾的缓存页，而被淘汰的缓存页却是经常被访问的。这种情况就是预读失效，被预先加载进缓冲池的页，并没有被访问到，这种情况是不是很不合理。
>
> **缓冲池污染** 
> 　　还有一种情况是当执行一条 SQL 语句时，如果扫描了大量数据或是进行了全表扫描，此时缓冲池中就会加载大量的数据页，从而将缓冲池中已存在的所有页替换出去，这种情况同样是不合理的。这就是缓冲池污染，并且还会导致 MySQL 性能急剧下降。



- #### 冷热数据分离

​		根据上面的两个问题来看，传统的 LRU 方法并不能满足缓冲池的空间管理。因此，Msyql 基于 LRU 设计了冷热数据分离的处理方案。

​		也就是将 LRU 链表分为两部分，一部分为热数据区域，一部分为冷数据区域。

![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/8.%E5%BC%95%E6%93%8E-InnoDB%E6%9E%B6%E6%9E%84-Buffer%20Pool-%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86-%E5%86%B7%E7%83%AD%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB.png?raw=true)

​		当数据页第一次被加载到缓冲池中的时候，先将其放到冷数据区域的链表头部，1s（由 innodb_old_blocks_time 参数控制） 后该缓存页被访问了再将其移至热数据区域的链表头部。

​		![](https://github.com/affectalways/Flee-as-a-bird-to-your-mountain/blob/main/MySQL/pictures/8.%E5%BC%95%E6%93%8E-InnoDB%E6%9E%B6%E6%9E%84-Buffer%20Pool-%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86-%E5%86%B7%E7%83%AD%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB2.png?raw=true)

​		可能你会有疑惑了，为什么要等 1s 后才将其移至热数据区域呢？你想想，如果数据页刚被加载到冷数据区就被访问了，之后再也不访问它了呢？这不就造成热数据区的浪费了吗？要是 1s 后不访问了，说明之后可能也不会去频繁访问它，也就没有移至热缓冲区的必要了。当缓存页不够的时候，从冷数据区淘汰它们就行了。 

　　另一种情况，当我的数据页已经在热缓冲区了，是不是缓存页只要被访问了就将其插到链表头部呢？不用我说你肯定也觉得不合理。热数据区域里的缓存页是会被经常访问的，如果每访问一个缓存页就插入一次链表头，那整个热缓冲区里就异常骚动了，你想想那个画面。

​		那咋整呢？Mysql 中优化为热数据区的后 3/4 部分被访问后才将其移动到链表头部去，对于前 1/4 部分的缓存页被访问了不会进行移动。



### Buffer Pool 预读机制

​		预读是mysql提高性能的一个重要的特性。**预读就是** IO 异步读取多个页数据读入 Buffer Pool 的一个过程，并且这些页被认为是很快就会被读取到的。InnoDB使用两种预读算法来提高I/O性能：**线性预读**（linear read-ahead）和**随机预读**（randomread-ahead）

　　这两种预读机制在此不详讲，感兴趣的朋友可以Google。



### Buffer Pool 的三种Page和链表

​		为了提高数据的读取速度，Buffer Pool 会通过三种Page 和链表来管理这些经常访问的数据，保证热数据不被置换出Buffer Pool。

- #### 三种Page

  - Free Page（空闲页）

  > 表示此Page 未被使用，位于 Free 链表。

  - Clean Page（干净页）

  > 此Page 已被使用，但是页面未发生修改，位于LRU 链表。

  - Dirty Page（脏页）

  > 此Page 已被使用，页面已经被修改，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该Page 就变成了干净页。脏页 同时存在于LRU 链表和Flush 链表。

- #### 三种链表

  - Free链表

  - LRU 链表

  - Flush 链表

    > Flush 链表里面保存的都是脏页。

    

    

### 触发刷脏页的条件

​		SQL 的增删改查都在 `Buffer Pool` 中执行，慢慢地，`Buffer Pool` 中的缓存页因为不断被修改而导致和磁盘文件中的数据不一致了，也就是 `Buffer Pool` 中会有很多个脏页，脏页里面很多脏数据。

​		所以，MySQL 会有一条后台线程，定时地将 `Buffer Pool` 中的脏页刷回到磁盘文件中。

> 1. REDO日志快用满的时候。由于MySQL更新是先写REDO日志，后面再将数据Flush到磁盘，如果REDO日志对应脏数据还没有刷新到磁盘就被覆盖的话，万一发生Crash，数据就无法恢复了。此时会从Flush 链表里面选取脏页，进行Flush。
> 2. 为了保证MySQL中的空闲页面的数量，Page Cleaner线程会从LRU 链表尾部淘汰一部分页面作为空闲页。如果对应的页面是脏页的话，就需要先将页面Flush到磁盘。
> 3. MySQL中脏页太多的时候。innodb_max_dirty_pages_pct 表示的是Buffer Pool最大的脏页比例，默认值是75%，当脏页比例大于这个值时会强制进行刷脏页，保证系统有足够可用的Free Page。innodb_max_dirty_pages_pct_lwm参数控制的是脏页比例的低水位，当达到该参数设定的时候，会进行preflush，避免比例达到innodb_max_dirty_pages_pct 来强制Flush，对MySQL实例产生影响。
> 4. MySQL实例正常关闭的时候，也会触发MySQL把内存里面的脏页全部刷新到磁盘。

​	

​		Innodb 的策略是在运行过程中尽可能的多占用内存，因此未被使用的页面会很少。当我们读取的数据不在Buffer Pool里面时，就需要申请一个空闲页来存放。如果没有足够的空闲页时，就必须从LRU 链表的尾部淘汰页面。如果该页面是干净的，可以直接拿来用，如果是脏页，就需要进行刷脏操作，将内存数据Flush到磁盘。

所以，如果出现以下情况，是很容易影响MySQL实例的性能：

1. 一个SQL查询的数据页需要淘汰的页面过多
2. 实例是个写多型的MySQL，checkpoint跟不上日志产生量，会导致更新全部堵塞，TPS跌0。

​		innodb_io_capacity 参数定义了Innodb 后台任务的IO能力，例如刷脏操作还有Change Buffer的merge操作等。

​		**Innodb 的三种Page和链表的设计，保证了我们需要的热数据常驻在内存，及时淘汰不需要的数据，提升了我们的查询速度，同时不同的刷脏策略也提高了我们的恢复速度，保证了数据安全。**



### 疑问

> 既然DML是对缓存池执行，那么缓存池的数据更新了，但还没有同步到磁盘，但是这时数据库突然宕机了，那么内存中更新的数据不就都没了？

针对这个问题，mysql引入了**日志机制（redo log）**,当对缓冲池里面的数据进行DML的时候，mysql会把DML的记录写入日志文件中（redo log之后会有详解），万一数据库突然宕机，只要从redo log日志里面读取之前的做过的DML操作，瞬间就可以重新把这些DML操作在内存执行一遍，这样就可以恢复之前做过的DML操作。当然对数据更新的过程，MySQL是有一套严密的步骤，还涉及到undo log、binlog、事务、buffer pool脏数据处理等等。





### 参考链接

- [MySQL Buffer Pool详解](https://www.cnblogs.com/better-farther-world2099/articles/14768929.html)