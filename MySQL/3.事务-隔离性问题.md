# 3.事务-隔离性问题

> 当数据库上有多个事务同时执行时，就可能出现**脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）**的问题，为了解决这些问题，就有了**“隔离级别”**的概念。



### 数据准备

为了演示`脏读`、`不可重复读`、`幻读`等问题，准备了一些初始化数据如下：

```
-- ----------------------------
--  table structure for `tb_book`
-- ----------------------------
CREATE TABLE `tb_book` (
  `book_id` int(11) NOT NULL,
  `book_name` varchar(64) DEFAULT NULL,
  `author` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`book_id`),
  UNIQUE KEY `uk_book_name` (`book_name`) USING BTREE
) ENGINE = InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

BEGIN;
INSERT INTO `tb_book`(`book_id`, `book_name`, `author`) VALUES (1, '多情剑客无情剑', '古龙');
INSERT INTO `tb_book`(`book_id`, `book_name`, `author`) VALUES (2, '笑傲江湖', '金庸');
INSERT INTO `tb_book`(`book_id`, `book_name`, `author`) VALUES (3, '倚天屠龙记', '金庸');
INSERT INTO `tb_book`(`book_id`, `book_name`, `author`) VALUES (4, '射雕英雄传', '金庸');
INSERT INTO `tb_book`(`book_id`, `book_name`, `author`) VALUES (5, '绝代双骄', '古龙');
COMMIT;
```



## 脏读

> 事务A读到了事务B已经修改但尚未提交的数据

操作：

1. 事务隔离级别设置为`read uncommitted`
2. `session A`开启事务，首次查询`book_id`为1的记录；
3. 然后`session B`开启事务，并修改`book_id`为1的记录，不提交事务，在`session A`中再次查询`book_id`为1的记录；
4. 最后让`session B`中的事务回滚，再在`session A`中查询`book_id`为1的记录。

```
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from tb_book where book_id = 1;
+---------+-----------------------+--------+
| book_id | book_name             | author |
+---------+-----------------------+--------+
|       1 | 多情剑客无情剑        | 古龙   |
+---------+-----------------------+--------+
1 row in set (0.00 sec)

mysql> select * from tb_book where book_id = 1;
+---------+-----------------------+--------+
| book_id | book_name             | author |
+---------+-----------------------+--------+
|       1 | 多情刀客无情刀        | 古龙   |
+---------+-----------------------+--------+
1 row in set (0.00 sec)

mysql> select * from tb_book where book_id = 1;
+---------+-----------------------+--------+
| book_id | book_name             | author |
+---------+-----------------------+--------+
|       1 | 多情剑客无情剑        | 古龙   |
+---------+-----------------------+--------+
1 row in set (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```

session B：

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> update tb_book set book_name = '多情刀客无情刀' where book_id = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> rollback;
Query OK, 0 rows affected (0.00 sec)
```

结果：`事务A`读到了`事务B`还没提交的中间状态，即产生了`脏读`。



## 不可重复读

> 事务A读到了事务B已经提交的修改数据

操作：

1. 事务隔离级别设置为`read committed`
2. `session A`开启事务，首次查询`book_id`为1的记录；
3. 然后`session B`开启事务，并修改`book_id`为1的记录，不提交事务，在`session A`中再次查询`book_id`为1的记录；
4. 最后提交`session B`中的事务，再在`session A`中查看`book_id`为1的记录。

session A：

```
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from tb_book where book_id = 1;
+---------+-----------------------+--------+
| book_id | book_name             | author |
+---------+-----------------------+--------+
|       1 | 多情剑客无情剑        | 古龙   |
+---------+-----------------------+--------+
1 row in set (0.00 sec)

mysql> select * from tb_book where book_id = 1;
+---------+-----------------------+--------+
| book_id | book_name             | author |
+---------+-----------------------+--------+
|       1 | 多情剑客无情剑        | 古龙   |
+---------+-----------------------+--------+
1 row in set (0.00 sec)

mysql> select * from tb_book where book_id = 1;
+---------+-----------------------+--------+
| book_id | book_name             | author |
+---------+-----------------------+--------+
|       1 | 多情刀客无情刀        | 古龙   |
+---------+-----------------------+--------+
1 row in set (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```

session B：

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> update tb_book set book_name = '多情刀客无情刀' where book_id = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```

结果：`事务B`没有提交事务时，`事务A`不会读到`事务B`修改的中间状态，即`read committed`解决了上面所说的`脏读`问题，但是当`事务B`中的事务提交后，`事务A`读到了修改后的记录，而对于`事务A`来说，仅仅读了两次，却读到了两个不同的结果，违背了事务之间的隔离性，所以说该事务隔离级别下产生了`不可重复读`的问题。



## 幻读

> 事务A读到了事务B提交的新增数据

操作：

1. 事务隔离级别设置为`repeatable read`
2. `session A`开启事务，并查询`book`列表
3. `session B`开启事务，先修改`book_id`为5的记录，再插入一条新的数据，提交事务，在`session A`中再次查询`book`列表
4. 在`session A`中更新`session B`中新插入的那条数据，再查询`book`列表

session A：

```
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from tb_book;
+---------+-----------------------+--------+
| book_id | book_name             | author |
+---------+-----------------------+--------+
|       1 | 多情刀客无情刀        | 古龙   |
|       2 | 笑傲江湖              | 金庸   |
|       3 | 倚天屠龙记            | 金庸   |
|       4 | 射雕英雄传            | 金庸   |
|       5 | 绝代双骄              | 古龙   |
+---------+-----------------------+--------+
5 rows in set (0.00 sec)

mysql> select * from tb_book;
+---------+-----------------------+--------+
| book_id | book_name             | author |
+---------+-----------------------+--------+
|       1 | 多情刀客无情刀        | 古龙   |
|       2 | 笑傲江湖              | 金庸   |
|       3 | 倚天屠龙记            | 金庸   |
|       4 | 射雕英雄传            | 金庸   |
|       5 | 绝代双骄              | 古龙   |
+---------+-----------------------+--------+
5 rows in set (0.00 sec)

mysql> update tb_book set book_name = '圆月弯剑' where book_id = 6;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from tb_book;
+---------+-----------------------+--------+
| book_id | book_name             | author |
+---------+-----------------------+--------+
|       1 | 多情刀客无情刀        | 古龙   |
|       2 | 笑傲江湖              | 金庸   |
|       3 | 倚天屠龙记            | 金庸   |
|       4 | 射雕英雄传            | 金庸   |
|       5 | 绝代双骄              | 古龙   |
|       6 | 圆月弯剑              | 古龙   |
+---------+-----------------------+--------+
6 rows in set (0.00 sec)

mysql> rollback;
Query OK, 0 rows affected (0.00 sec)
```

session B：

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> update tb_book set book_name = '绝代双雄' where book_id = 5;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> insert into tb_book values (6, '圆月弯刀', '古龙');
Query OK, 1 row affected (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from tb_book;
+---------+-----------------------+--------+
| book_id | book_name             | author |
+---------+-----------------------+--------+
|       1 | 多情刀客无情刀        | 古龙   |
|       2 | 笑傲江湖              | 金庸   |
|       3 | 倚天屠龙记            | 金庸   |
|       4 | 射雕英雄传            | 金庸   |
|       5 | 绝代双雄              | 古龙   |
|       6 | 圆月弯刀              | 古龙   |
+---------+-----------------------+--------+
6 rows in set (0.00 sec)
```

结果：`事务B`已提交的修改记录(即`绝代双骄`修改为`绝代双雄`)在`事务A`中是不可见的，说明该事务隔离级别下解决了上面`不可重复读`的问题，但魔幻的是一开始`事务A`中虽然读不到`事务B`中的新增记录，却可以更新这条新增记录，执行更新(`update`)后，在`事务A`中居然可见该新增记录了，这便产生了所谓的`幻读`问题。

**为什么会出现这样莫名其妙的结果？** 别急，后文会慢慢揭开这个神秘的面纱。先看如何解决幻读问题。


